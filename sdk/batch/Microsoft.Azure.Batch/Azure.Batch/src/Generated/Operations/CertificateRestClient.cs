// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Batch.Models;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Batch
{
    internal partial class CertificateRestClient
    {
        private string batchUrl;
        private string apiVersion;
        private ClientDiagnostics clientDiagnostics;
        private HttpPipeline pipeline;

        /// <summary> Initializes a new instance of CertificateRestClient. </summary>
        public CertificateRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string batchUrl, string apiVersion = "2020-03-01.11.0")
        {
            if (batchUrl == null)
            {
                throw new ArgumentNullException(nameof(batchUrl));
            }
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            this.batchUrl = batchUrl;
            this.apiVersion = apiVersion;
            this.clientDiagnostics = clientDiagnostics;
            this.pipeline = pipeline;
        }

        internal HttpMessage CreateAddRequest(CertificateAddParameter certificate, CertificateAddOptions certificateAddOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/certificates", false);
            if (certificateAddOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", certificateAddOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (certificateAddOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", certificateAddOptions.ClientRequestId.Value);
            }
            if (certificateAddOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", certificateAddOptions.ReturnClientRequestId.Value);
            }
            if (certificateAddOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", certificateAddOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            using var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(certificate);
            request.Content = content;
            return message;
        }

        /// <summary> Adds a Certificate to the specified Account. </summary>
        /// <param name="certificate"> The Certificate to be added. </param>
        /// <param name="certificateAddOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<AddHeaders>> AddAsync(CertificateAddParameter certificate, CertificateAddOptions certificateAddOptions, CancellationToken cancellationToken = default)
        {
            if (certificate == null)
            {
                throw new ArgumentNullException(nameof(certificate));
            }

            using var scope = clientDiagnostics.CreateScope("CertificateClient.Add");
            scope.Start();
            try
            {
                using var message = CreateAddRequest(certificate, certificateAddOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new AddHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 201:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Adds a Certificate to the specified Account. </summary>
        /// <param name="certificate"> The Certificate to be added. </param>
        /// <param name="certificateAddOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<AddHeaders> Add(CertificateAddParameter certificate, CertificateAddOptions certificateAddOptions, CancellationToken cancellationToken = default)
        {
            if (certificate == null)
            {
                throw new ArgumentNullException(nameof(certificate));
            }

            using var scope = clientDiagnostics.CreateScope("CertificateClient.Add");
            scope.Start();
            try
            {
                using var message = CreateAddRequest(certificate, certificateAddOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new AddHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 201:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateListRequest(CertificateListOptions certificateListOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/certificates", false);
            if (certificateListOptions?.Filter != null)
            {
                uri.AppendQuery("$filter", certificateListOptions.Filter, true);
            }
            if (certificateListOptions?.Select != null)
            {
                uri.AppendQuery("$select", certificateListOptions.Select, true);
            }
            if (certificateListOptions?.MaxResults != null)
            {
                uri.AppendQuery("maxresults", certificateListOptions.MaxResults.Value, true);
            }
            if (certificateListOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", certificateListOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (certificateListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", certificateListOptions.ClientRequestId.Value);
            }
            if (certificateListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", certificateListOptions.ReturnClientRequestId.Value);
            }
            if (certificateListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", certificateListOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Lists all of the Certificates that have been added to the specified Account. </summary>
        /// <param name="certificateListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<CertificateListResult, ListHeaders>> ListAsync(CertificateListOptions certificateListOptions, CancellationToken cancellationToken = default)
        {
            using var scope = clientDiagnostics.CreateScope("CertificateClient.List");
            scope.Start();
            try
            {
                using var message = CreateListRequest(certificateListOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new ListHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            CertificateListResult value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = CertificateListResult.DeserializeCertificateListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all of the Certificates that have been added to the specified Account. </summary>
        /// <param name="certificateListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<CertificateListResult, ListHeaders> List(CertificateListOptions certificateListOptions, CancellationToken cancellationToken = default)
        {
            using var scope = clientDiagnostics.CreateScope("CertificateClient.List");
            scope.Start();
            try
            {
                using var message = CreateListRequest(certificateListOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new ListHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            CertificateListResult value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = CertificateListResult.DeserializeCertificateListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateCancelDeletionRequest(string thumbprintAlgorithm, string thumbprint, CertificateCancelDeletionOptions certificateCancelDeletionOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/certificates(thumbprintAlgorithm=", false);
            uri.AppendPath(thumbprintAlgorithm, true);
            uri.AppendPath(",thumbprint=", false);
            uri.AppendPath(thumbprint, true);
            uri.AppendPath(")/canceldelete", false);
            if (certificateCancelDeletionOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", certificateCancelDeletionOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (certificateCancelDeletionOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", certificateCancelDeletionOptions.ClientRequestId.Value);
            }
            if (certificateCancelDeletionOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", certificateCancelDeletionOptions.ReturnClientRequestId.Value);
            }
            if (certificateCancelDeletionOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", certificateCancelDeletionOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> If you try to delete a Certificate that is being used by a Pool or Compute Node, the status of the Certificate changes to deleteFailed. If you decide that you want to continue using the Certificate, you can use this operation to set the status of the Certificate back to active. If you intend to delete the Certificate, you do not need to run this operation after the deletion failed. You must make sure that the Certificate is not being used by any resources, and then you can try again to delete the Certificate. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate being deleted. </param>
        /// <param name="certificateCancelDeletionOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<CancelDeletionHeaders>> CancelDeletionAsync(string thumbprintAlgorithm, string thumbprint, CertificateCancelDeletionOptions certificateCancelDeletionOptions, CancellationToken cancellationToken = default)
        {
            if (thumbprintAlgorithm == null)
            {
                throw new ArgumentNullException(nameof(thumbprintAlgorithm));
            }
            if (thumbprint == null)
            {
                throw new ArgumentNullException(nameof(thumbprint));
            }

            using var scope = clientDiagnostics.CreateScope("CertificateClient.CancelDeletion");
            scope.Start();
            try
            {
                using var message = CreateCancelDeletionRequest(thumbprintAlgorithm, thumbprint, certificateCancelDeletionOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new CancelDeletionHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 204:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> If you try to delete a Certificate that is being used by a Pool or Compute Node, the status of the Certificate changes to deleteFailed. If you decide that you want to continue using the Certificate, you can use this operation to set the status of the Certificate back to active. If you intend to delete the Certificate, you do not need to run this operation after the deletion failed. You must make sure that the Certificate is not being used by any resources, and then you can try again to delete the Certificate. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate being deleted. </param>
        /// <param name="certificateCancelDeletionOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<CancelDeletionHeaders> CancelDeletion(string thumbprintAlgorithm, string thumbprint, CertificateCancelDeletionOptions certificateCancelDeletionOptions, CancellationToken cancellationToken = default)
        {
            if (thumbprintAlgorithm == null)
            {
                throw new ArgumentNullException(nameof(thumbprintAlgorithm));
            }
            if (thumbprint == null)
            {
                throw new ArgumentNullException(nameof(thumbprint));
            }

            using var scope = clientDiagnostics.CreateScope("CertificateClient.CancelDeletion");
            scope.Start();
            try
            {
                using var message = CreateCancelDeletionRequest(thumbprintAlgorithm, thumbprint, certificateCancelDeletionOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new CancelDeletionHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 204:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateDeleteRequest(string thumbprintAlgorithm, string thumbprint, CertificateDeleteOptions certificateDeleteOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/certificates(thumbprintAlgorithm=", false);
            uri.AppendPath(thumbprintAlgorithm, true);
            uri.AppendPath(",thumbprint=", false);
            uri.AppendPath(thumbprint, true);
            uri.AppendPath(")", false);
            if (certificateDeleteOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", certificateDeleteOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (certificateDeleteOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", certificateDeleteOptions.ClientRequestId.Value);
            }
            if (certificateDeleteOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", certificateDeleteOptions.ReturnClientRequestId.Value);
            }
            if (certificateDeleteOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", certificateDeleteOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> You cannot delete a Certificate if a resource (Pool or Compute Node) is using it. Before you can delete a Certificate, you must therefore make sure that the Certificate is not associated with any existing Pools, the Certificate is not installed on any Nodes (even if you remove a Certificate from a Pool, it is not removed from existing Compute Nodes in that Pool until they restart), and no running Tasks depend on the Certificate. If you try to delete a Certificate that is in use, the deletion fails. The Certificate status changes to deleteFailed. You can use Cancel Delete Certificate to set the status back to active if you decide that you want to continue using the Certificate. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate to be deleted. </param>
        /// <param name="certificateDeleteOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<DeleteHeaders>> DeleteAsync(string thumbprintAlgorithm, string thumbprint, CertificateDeleteOptions certificateDeleteOptions, CancellationToken cancellationToken = default)
        {
            if (thumbprintAlgorithm == null)
            {
                throw new ArgumentNullException(nameof(thumbprintAlgorithm));
            }
            if (thumbprint == null)
            {
                throw new ArgumentNullException(nameof(thumbprint));
            }

            using var scope = clientDiagnostics.CreateScope("CertificateClient.Delete");
            scope.Start();
            try
            {
                using var message = CreateDeleteRequest(thumbprintAlgorithm, thumbprint, certificateDeleteOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new DeleteHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 202:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You cannot delete a Certificate if a resource (Pool or Compute Node) is using it. Before you can delete a Certificate, you must therefore make sure that the Certificate is not associated with any existing Pools, the Certificate is not installed on any Nodes (even if you remove a Certificate from a Pool, it is not removed from existing Compute Nodes in that Pool until they restart), and no running Tasks depend on the Certificate. If you try to delete a Certificate that is in use, the deletion fails. The Certificate status changes to deleteFailed. You can use Cancel Delete Certificate to set the status back to active if you decide that you want to continue using the Certificate. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate to be deleted. </param>
        /// <param name="certificateDeleteOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<DeleteHeaders> Delete(string thumbprintAlgorithm, string thumbprint, CertificateDeleteOptions certificateDeleteOptions, CancellationToken cancellationToken = default)
        {
            if (thumbprintAlgorithm == null)
            {
                throw new ArgumentNullException(nameof(thumbprintAlgorithm));
            }
            if (thumbprint == null)
            {
                throw new ArgumentNullException(nameof(thumbprint));
            }

            using var scope = clientDiagnostics.CreateScope("CertificateClient.Delete");
            scope.Start();
            try
            {
                using var message = CreateDeleteRequest(thumbprintAlgorithm, thumbprint, certificateDeleteOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new DeleteHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 202:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetRequest(string thumbprintAlgorithm, string thumbprint, CertificateGetOptions certificateGetOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/certificates(thumbprintAlgorithm=", false);
            uri.AppendPath(thumbprintAlgorithm, true);
            uri.AppendPath(",thumbprint=", false);
            uri.AppendPath(thumbprint, true);
            uri.AppendPath(")", false);
            if (certificateGetOptions?.Select != null)
            {
                uri.AppendQuery("$select", certificateGetOptions.Select, true);
            }
            if (certificateGetOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", certificateGetOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (certificateGetOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", certificateGetOptions.ClientRequestId.Value);
            }
            if (certificateGetOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", certificateGetOptions.ReturnClientRequestId.Value);
            }
            if (certificateGetOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", certificateGetOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Gets information about the specified Certificate. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate to get. </param>
        /// <param name="certificateGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<Certificate, GetHeaders>> GetAsync(string thumbprintAlgorithm, string thumbprint, CertificateGetOptions certificateGetOptions, CancellationToken cancellationToken = default)
        {
            if (thumbprintAlgorithm == null)
            {
                throw new ArgumentNullException(nameof(thumbprintAlgorithm));
            }
            if (thumbprint == null)
            {
                throw new ArgumentNullException(nameof(thumbprint));
            }

            using var scope = clientDiagnostics.CreateScope("CertificateClient.Get");
            scope.Start();
            try
            {
                using var message = CreateGetRequest(thumbprintAlgorithm, thumbprint, certificateGetOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new GetHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            Certificate value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = Certificate.DeserializeCertificate(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Certificate. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate to get. </param>
        /// <param name="certificateGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<Certificate, GetHeaders> Get(string thumbprintAlgorithm, string thumbprint, CertificateGetOptions certificateGetOptions, CancellationToken cancellationToken = default)
        {
            if (thumbprintAlgorithm == null)
            {
                throw new ArgumentNullException(nameof(thumbprintAlgorithm));
            }
            if (thumbprint == null)
            {
                throw new ArgumentNullException(nameof(thumbprint));
            }

            using var scope = clientDiagnostics.CreateScope("CertificateClient.Get");
            scope.Start();
            try
            {
                using var message = CreateGetRequest(thumbprintAlgorithm, thumbprint, certificateGetOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new GetHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            Certificate value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = Certificate.DeserializeCertificate(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateListNextPageRequest(string nextLink, CertificateListOptions certificateListOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(nextLink, false);
            request.Uri = uri;
            if (certificateListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", certificateListOptions.ClientRequestId.Value);
            }
            if (certificateListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", certificateListOptions.ReturnClientRequestId.Value);
            }
            if (certificateListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", certificateListOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Lists all of the Certificates that have been added to the specified Account. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="certificateListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<CertificateListResult, ListHeaders>> ListNextPageAsync(string nextLink, CertificateListOptions certificateListOptions, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            using var scope = clientDiagnostics.CreateScope("CertificateClient.List");
            scope.Start();
            try
            {
                using var message = CreateListNextPageRequest(nextLink, certificateListOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new ListHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            CertificateListResult value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = CertificateListResult.DeserializeCertificateListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all of the Certificates that have been added to the specified Account. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="certificateListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<CertificateListResult, ListHeaders> ListNextPage(string nextLink, CertificateListOptions certificateListOptions, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            using var scope = clientDiagnostics.CreateScope("CertificateClient.List");
            scope.Start();
            try
            {
                using var message = CreateListNextPageRequest(nextLink, certificateListOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new ListHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            CertificateListResult value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = CertificateListResult.DeserializeCertificateListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}
