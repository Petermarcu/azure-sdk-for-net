// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Batch.Models;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Batch
{
    internal partial class JobScheduleRestClient
    {
        private string batchUrl;
        private string apiVersion;
        private ClientDiagnostics clientDiagnostics;
        private HttpPipeline pipeline;

        /// <summary> Initializes a new instance of JobScheduleRestClient. </summary>
        public JobScheduleRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string batchUrl, string apiVersion = "2020-03-01.11.0")
        {
            if (batchUrl == null)
            {
                throw new ArgumentNullException(nameof(batchUrl));
            }
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            this.batchUrl = batchUrl;
            this.apiVersion = apiVersion;
            this.clientDiagnostics = clientDiagnostics;
            this.pipeline = pipeline;
        }

        internal HttpMessage CreateExistsRequest(string jobScheduleId, JobScheduleExistsOptions jobScheduleExistsOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/jobschedules/", false);
            uri.AppendPath(jobScheduleId, true);
            if (jobScheduleExistsOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobScheduleExistsOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (jobScheduleExistsOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobScheduleExistsOptions.ClientRequestId.Value);
            }
            if (jobScheduleExistsOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobScheduleExistsOptions.ReturnClientRequestId.Value);
            }
            if (jobScheduleExistsOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobScheduleExistsOptions.OcpDate.Value, "R");
            }
            if (jobScheduleExistsOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", jobScheduleExistsOptions.IfMatch);
            }
            if (jobScheduleExistsOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", jobScheduleExistsOptions.IfNoneMatch);
            }
            if (jobScheduleExistsOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", jobScheduleExistsOptions.IfModifiedSince.Value, "R");
            }
            if (jobScheduleExistsOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", jobScheduleExistsOptions.IfUnmodifiedSince.Value, "R");
            }
            return message;
        }

        /// <summary> Checks the specified Job Schedule exists. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule which you want to check. </param>
        /// <param name="jobScheduleExistsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<ExistsHeaders>> ExistsAsync(string jobScheduleId, JobScheduleExistsOptions jobScheduleExistsOptions, CancellationToken cancellationToken = default)
        {
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.Exists");
            scope.Start();
            try
            {
                using var message = CreateExistsRequest(jobScheduleId, jobScheduleExistsOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new ExistsHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                    case 404:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Checks the specified Job Schedule exists. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule which you want to check. </param>
        /// <param name="jobScheduleExistsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<ExistsHeaders> Exists(string jobScheduleId, JobScheduleExistsOptions jobScheduleExistsOptions, CancellationToken cancellationToken = default)
        {
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.Exists");
            scope.Start();
            try
            {
                using var message = CreateExistsRequest(jobScheduleId, jobScheduleExistsOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new ExistsHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                    case 404:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateDeleteRequest(string jobScheduleId, JobScheduleDeleteOptions jobScheduleDeleteOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/jobschedules/", false);
            uri.AppendPath(jobScheduleId, true);
            if (jobScheduleDeleteOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobScheduleDeleteOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (jobScheduleDeleteOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobScheduleDeleteOptions.ClientRequestId.Value);
            }
            if (jobScheduleDeleteOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobScheduleDeleteOptions.ReturnClientRequestId.Value);
            }
            if (jobScheduleDeleteOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobScheduleDeleteOptions.OcpDate.Value, "R");
            }
            if (jobScheduleDeleteOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", jobScheduleDeleteOptions.IfMatch);
            }
            if (jobScheduleDeleteOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", jobScheduleDeleteOptions.IfNoneMatch);
            }
            if (jobScheduleDeleteOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", jobScheduleDeleteOptions.IfModifiedSince.Value, "R");
            }
            if (jobScheduleDeleteOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", jobScheduleDeleteOptions.IfUnmodifiedSince.Value, "R");
            }
            return message;
        }

        /// <summary> When you delete a Job Schedule, this also deletes all Jobs and Tasks under that schedule. When Tasks are deleted, all the files in their working directories on the Compute Nodes are also deleted (the retention period is ignored). The Job Schedule statistics are no longer accessible once the Job Schedule is deleted, though they are still counted towards Account lifetime statistics. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to delete. </param>
        /// <param name="jobScheduleDeleteOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<DeleteHeaders>> DeleteAsync(string jobScheduleId, JobScheduleDeleteOptions jobScheduleDeleteOptions, CancellationToken cancellationToken = default)
        {
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.Delete");
            scope.Start();
            try
            {
                using var message = CreateDeleteRequest(jobScheduleId, jobScheduleDeleteOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new DeleteHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 202:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> When you delete a Job Schedule, this also deletes all Jobs and Tasks under that schedule. When Tasks are deleted, all the files in their working directories on the Compute Nodes are also deleted (the retention period is ignored). The Job Schedule statistics are no longer accessible once the Job Schedule is deleted, though they are still counted towards Account lifetime statistics. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to delete. </param>
        /// <param name="jobScheduleDeleteOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<DeleteHeaders> Delete(string jobScheduleId, JobScheduleDeleteOptions jobScheduleDeleteOptions, CancellationToken cancellationToken = default)
        {
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.Delete");
            scope.Start();
            try
            {
                using var message = CreateDeleteRequest(jobScheduleId, jobScheduleDeleteOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new DeleteHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 202:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetRequest(string jobScheduleId, JobScheduleGetOptions jobScheduleGetOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/jobschedules/", false);
            uri.AppendPath(jobScheduleId, true);
            if (jobScheduleGetOptions?.Select != null)
            {
                uri.AppendQuery("$select", jobScheduleGetOptions.Select, true);
            }
            if (jobScheduleGetOptions?.Expand != null)
            {
                uri.AppendQuery("$expand", jobScheduleGetOptions.Expand, true);
            }
            if (jobScheduleGetOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobScheduleGetOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (jobScheduleGetOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobScheduleGetOptions.ClientRequestId.Value);
            }
            if (jobScheduleGetOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobScheduleGetOptions.ReturnClientRequestId.Value);
            }
            if (jobScheduleGetOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobScheduleGetOptions.OcpDate.Value, "R");
            }
            if (jobScheduleGetOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", jobScheduleGetOptions.IfMatch);
            }
            if (jobScheduleGetOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", jobScheduleGetOptions.IfNoneMatch);
            }
            if (jobScheduleGetOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", jobScheduleGetOptions.IfModifiedSince.Value, "R");
            }
            if (jobScheduleGetOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", jobScheduleGetOptions.IfUnmodifiedSince.Value, "R");
            }
            return message;
        }

        /// <summary> Gets information about the specified Job Schedule. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to get. </param>
        /// <param name="jobScheduleGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<CloudJobSchedule, GetHeaders>> GetAsync(string jobScheduleId, JobScheduleGetOptions jobScheduleGetOptions, CancellationToken cancellationToken = default)
        {
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.Get");
            scope.Start();
            try
            {
                using var message = CreateGetRequest(jobScheduleId, jobScheduleGetOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new GetHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            CloudJobSchedule value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = CloudJobSchedule.DeserializeCloudJobSchedule(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Job Schedule. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to get. </param>
        /// <param name="jobScheduleGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<CloudJobSchedule, GetHeaders> Get(string jobScheduleId, JobScheduleGetOptions jobScheduleGetOptions, CancellationToken cancellationToken = default)
        {
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.Get");
            scope.Start();
            try
            {
                using var message = CreateGetRequest(jobScheduleId, jobScheduleGetOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new GetHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            CloudJobSchedule value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = CloudJobSchedule.DeserializeCloudJobSchedule(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreatePatchRequest(string jobScheduleId, JobSchedulePatchParameter jobSchedulePatchParameter, JobSchedulePatchOptions jobSchedulePatchOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/jobschedules/", false);
            uri.AppendPath(jobScheduleId, true);
            if (jobSchedulePatchOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobSchedulePatchOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (jobSchedulePatchOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobSchedulePatchOptions.ClientRequestId.Value);
            }
            if (jobSchedulePatchOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobSchedulePatchOptions.ReturnClientRequestId.Value);
            }
            if (jobSchedulePatchOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobSchedulePatchOptions.OcpDate.Value, "R");
            }
            if (jobSchedulePatchOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", jobSchedulePatchOptions.IfMatch);
            }
            if (jobSchedulePatchOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", jobSchedulePatchOptions.IfNoneMatch);
            }
            if (jobSchedulePatchOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", jobSchedulePatchOptions.IfModifiedSince.Value, "R");
            }
            if (jobSchedulePatchOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", jobSchedulePatchOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            using var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(jobSchedulePatchParameter);
            request.Content = content;
            return message;
        }

        /// <summary> This replaces only the Job Schedule properties specified in the request. For example, if the schedule property is not specified with this request, then the Batch service will keep the existing schedule. Changes to a Job Schedule only impact Jobs created by the schedule after the update has taken place; currently running Jobs are unaffected. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to update. </param>
        /// <param name="jobSchedulePatchParameter"> The parameters for the request. </param>
        /// <param name="jobSchedulePatchOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<PatchHeaders>> PatchAsync(string jobScheduleId, JobSchedulePatchParameter jobSchedulePatchParameter, JobSchedulePatchOptions jobSchedulePatchOptions, CancellationToken cancellationToken = default)
        {
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }
            if (jobSchedulePatchParameter == null)
            {
                throw new ArgumentNullException(nameof(jobSchedulePatchParameter));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.Patch");
            scope.Start();
            try
            {
                using var message = CreatePatchRequest(jobScheduleId, jobSchedulePatchParameter, jobSchedulePatchOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new PatchHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This replaces only the Job Schedule properties specified in the request. For example, if the schedule property is not specified with this request, then the Batch service will keep the existing schedule. Changes to a Job Schedule only impact Jobs created by the schedule after the update has taken place; currently running Jobs are unaffected. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to update. </param>
        /// <param name="jobSchedulePatchParameter"> The parameters for the request. </param>
        /// <param name="jobSchedulePatchOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<PatchHeaders> Patch(string jobScheduleId, JobSchedulePatchParameter jobSchedulePatchParameter, JobSchedulePatchOptions jobSchedulePatchOptions, CancellationToken cancellationToken = default)
        {
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }
            if (jobSchedulePatchParameter == null)
            {
                throw new ArgumentNullException(nameof(jobSchedulePatchParameter));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.Patch");
            scope.Start();
            try
            {
                using var message = CreatePatchRequest(jobScheduleId, jobSchedulePatchParameter, jobSchedulePatchOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new PatchHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateUpdateRequest(string jobScheduleId, JobScheduleUpdateParameter jobScheduleUpdateParameter, JobScheduleUpdateOptions jobScheduleUpdateOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/jobschedules/", false);
            uri.AppendPath(jobScheduleId, true);
            if (jobScheduleUpdateOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobScheduleUpdateOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (jobScheduleUpdateOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobScheduleUpdateOptions.ClientRequestId.Value);
            }
            if (jobScheduleUpdateOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobScheduleUpdateOptions.ReturnClientRequestId.Value);
            }
            if (jobScheduleUpdateOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobScheduleUpdateOptions.OcpDate.Value, "R");
            }
            if (jobScheduleUpdateOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", jobScheduleUpdateOptions.IfMatch);
            }
            if (jobScheduleUpdateOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", jobScheduleUpdateOptions.IfNoneMatch);
            }
            if (jobScheduleUpdateOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", jobScheduleUpdateOptions.IfModifiedSince.Value, "R");
            }
            if (jobScheduleUpdateOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", jobScheduleUpdateOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            using var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(jobScheduleUpdateParameter);
            request.Content = content;
            return message;
        }

        /// <summary> This fully replaces all the updatable properties of the Job Schedule. For example, if the schedule property is not specified with this request, then the Batch service will remove the existing schedule. Changes to a Job Schedule only impact Jobs created by the schedule after the update has taken place; currently running Jobs are unaffected. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to update. </param>
        /// <param name="jobScheduleUpdateParameter"> The parameters for the request. </param>
        /// <param name="jobScheduleUpdateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<UpdateHeaders>> UpdateAsync(string jobScheduleId, JobScheduleUpdateParameter jobScheduleUpdateParameter, JobScheduleUpdateOptions jobScheduleUpdateOptions, CancellationToken cancellationToken = default)
        {
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }
            if (jobScheduleUpdateParameter == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleUpdateParameter));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.Update");
            scope.Start();
            try
            {
                using var message = CreateUpdateRequest(jobScheduleId, jobScheduleUpdateParameter, jobScheduleUpdateOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new UpdateHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This fully replaces all the updatable properties of the Job Schedule. For example, if the schedule property is not specified with this request, then the Batch service will remove the existing schedule. Changes to a Job Schedule only impact Jobs created by the schedule after the update has taken place; currently running Jobs are unaffected. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to update. </param>
        /// <param name="jobScheduleUpdateParameter"> The parameters for the request. </param>
        /// <param name="jobScheduleUpdateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<UpdateHeaders> Update(string jobScheduleId, JobScheduleUpdateParameter jobScheduleUpdateParameter, JobScheduleUpdateOptions jobScheduleUpdateOptions, CancellationToken cancellationToken = default)
        {
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }
            if (jobScheduleUpdateParameter == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleUpdateParameter));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.Update");
            scope.Start();
            try
            {
                using var message = CreateUpdateRequest(jobScheduleId, jobScheduleUpdateParameter, jobScheduleUpdateOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new UpdateHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateDisableRequest(string jobScheduleId, JobScheduleDisableOptions jobScheduleDisableOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/jobschedules/", false);
            uri.AppendPath(jobScheduleId, true);
            uri.AppendPath("/disable", false);
            if (jobScheduleDisableOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobScheduleDisableOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (jobScheduleDisableOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobScheduleDisableOptions.ClientRequestId.Value);
            }
            if (jobScheduleDisableOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobScheduleDisableOptions.ReturnClientRequestId.Value);
            }
            if (jobScheduleDisableOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobScheduleDisableOptions.OcpDate.Value, "R");
            }
            if (jobScheduleDisableOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", jobScheduleDisableOptions.IfMatch);
            }
            if (jobScheduleDisableOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", jobScheduleDisableOptions.IfNoneMatch);
            }
            if (jobScheduleDisableOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", jobScheduleDisableOptions.IfModifiedSince.Value, "R");
            }
            if (jobScheduleDisableOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", jobScheduleDisableOptions.IfUnmodifiedSince.Value, "R");
            }
            return message;
        }

        /// <summary> No new Jobs will be created until the Job Schedule is enabled again. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to disable. </param>
        /// <param name="jobScheduleDisableOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<DisableHeaders>> DisableAsync(string jobScheduleId, JobScheduleDisableOptions jobScheduleDisableOptions, CancellationToken cancellationToken = default)
        {
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.Disable");
            scope.Start();
            try
            {
                using var message = CreateDisableRequest(jobScheduleId, jobScheduleDisableOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new DisableHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 204:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> No new Jobs will be created until the Job Schedule is enabled again. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to disable. </param>
        /// <param name="jobScheduleDisableOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<DisableHeaders> Disable(string jobScheduleId, JobScheduleDisableOptions jobScheduleDisableOptions, CancellationToken cancellationToken = default)
        {
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.Disable");
            scope.Start();
            try
            {
                using var message = CreateDisableRequest(jobScheduleId, jobScheduleDisableOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new DisableHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 204:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateEnableRequest(string jobScheduleId, JobScheduleEnableOptions jobScheduleEnableOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/jobschedules/", false);
            uri.AppendPath(jobScheduleId, true);
            uri.AppendPath("/enable", false);
            if (jobScheduleEnableOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobScheduleEnableOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (jobScheduleEnableOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobScheduleEnableOptions.ClientRequestId.Value);
            }
            if (jobScheduleEnableOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobScheduleEnableOptions.ReturnClientRequestId.Value);
            }
            if (jobScheduleEnableOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobScheduleEnableOptions.OcpDate.Value, "R");
            }
            if (jobScheduleEnableOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", jobScheduleEnableOptions.IfMatch);
            }
            if (jobScheduleEnableOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", jobScheduleEnableOptions.IfNoneMatch);
            }
            if (jobScheduleEnableOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", jobScheduleEnableOptions.IfModifiedSince.Value, "R");
            }
            if (jobScheduleEnableOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", jobScheduleEnableOptions.IfUnmodifiedSince.Value, "R");
            }
            return message;
        }

        /// <summary> Enables a Job Schedule. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to enable. </param>
        /// <param name="jobScheduleEnableOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<EnableHeaders>> EnableAsync(string jobScheduleId, JobScheduleEnableOptions jobScheduleEnableOptions, CancellationToken cancellationToken = default)
        {
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.Enable");
            scope.Start();
            try
            {
                using var message = CreateEnableRequest(jobScheduleId, jobScheduleEnableOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new EnableHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 204:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Enables a Job Schedule. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to enable. </param>
        /// <param name="jobScheduleEnableOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<EnableHeaders> Enable(string jobScheduleId, JobScheduleEnableOptions jobScheduleEnableOptions, CancellationToken cancellationToken = default)
        {
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.Enable");
            scope.Start();
            try
            {
                using var message = CreateEnableRequest(jobScheduleId, jobScheduleEnableOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new EnableHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 204:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateTerminateRequest(string jobScheduleId, JobScheduleTerminateOptions jobScheduleTerminateOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/jobschedules/", false);
            uri.AppendPath(jobScheduleId, true);
            uri.AppendPath("/terminate", false);
            if (jobScheduleTerminateOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobScheduleTerminateOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (jobScheduleTerminateOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobScheduleTerminateOptions.ClientRequestId.Value);
            }
            if (jobScheduleTerminateOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobScheduleTerminateOptions.ReturnClientRequestId.Value);
            }
            if (jobScheduleTerminateOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobScheduleTerminateOptions.OcpDate.Value, "R");
            }
            if (jobScheduleTerminateOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", jobScheduleTerminateOptions.IfMatch);
            }
            if (jobScheduleTerminateOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", jobScheduleTerminateOptions.IfNoneMatch);
            }
            if (jobScheduleTerminateOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", jobScheduleTerminateOptions.IfModifiedSince.Value, "R");
            }
            if (jobScheduleTerminateOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", jobScheduleTerminateOptions.IfUnmodifiedSince.Value, "R");
            }
            return message;
        }

        /// <summary> Terminates a Job Schedule. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to terminates. </param>
        /// <param name="jobScheduleTerminateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<TerminateHeaders>> TerminateAsync(string jobScheduleId, JobScheduleTerminateOptions jobScheduleTerminateOptions, CancellationToken cancellationToken = default)
        {
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.Terminate");
            scope.Start();
            try
            {
                using var message = CreateTerminateRequest(jobScheduleId, jobScheduleTerminateOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new TerminateHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 202:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Terminates a Job Schedule. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to terminates. </param>
        /// <param name="jobScheduleTerminateOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<TerminateHeaders> Terminate(string jobScheduleId, JobScheduleTerminateOptions jobScheduleTerminateOptions, CancellationToken cancellationToken = default)
        {
            if (jobScheduleId == null)
            {
                throw new ArgumentNullException(nameof(jobScheduleId));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.Terminate");
            scope.Start();
            try
            {
                using var message = CreateTerminateRequest(jobScheduleId, jobScheduleTerminateOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new TerminateHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 202:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateAddRequest(JobScheduleAddParameter cloudJobSchedule, JobScheduleAddOptions jobScheduleAddOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/jobschedules", false);
            if (jobScheduleAddOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobScheduleAddOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (jobScheduleAddOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobScheduleAddOptions.ClientRequestId.Value);
            }
            if (jobScheduleAddOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobScheduleAddOptions.ReturnClientRequestId.Value);
            }
            if (jobScheduleAddOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobScheduleAddOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            using var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(cloudJobSchedule);
            request.Content = content;
            return message;
        }

        /// <summary> Adds a Job Schedule to the specified Account. </summary>
        /// <param name="cloudJobSchedule"> The Job Schedule to be added. </param>
        /// <param name="jobScheduleAddOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<AddHeaders>> AddAsync(JobScheduleAddParameter cloudJobSchedule, JobScheduleAddOptions jobScheduleAddOptions, CancellationToken cancellationToken = default)
        {
            if (cloudJobSchedule == null)
            {
                throw new ArgumentNullException(nameof(cloudJobSchedule));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.Add");
            scope.Start();
            try
            {
                using var message = CreateAddRequest(cloudJobSchedule, jobScheduleAddOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new AddHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 201:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Adds a Job Schedule to the specified Account. </summary>
        /// <param name="cloudJobSchedule"> The Job Schedule to be added. </param>
        /// <param name="jobScheduleAddOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<AddHeaders> Add(JobScheduleAddParameter cloudJobSchedule, JobScheduleAddOptions jobScheduleAddOptions, CancellationToken cancellationToken = default)
        {
            if (cloudJobSchedule == null)
            {
                throw new ArgumentNullException(nameof(cloudJobSchedule));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.Add");
            scope.Start();
            try
            {
                using var message = CreateAddRequest(cloudJobSchedule, jobScheduleAddOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new AddHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 201:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateListRequest(JobScheduleListOptions jobScheduleListOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/jobschedules", false);
            if (jobScheduleListOptions?.Filter != null)
            {
                uri.AppendQuery("$filter", jobScheduleListOptions.Filter, true);
            }
            if (jobScheduleListOptions?.Select != null)
            {
                uri.AppendQuery("$select", jobScheduleListOptions.Select, true);
            }
            if (jobScheduleListOptions?.Expand != null)
            {
                uri.AppendQuery("$expand", jobScheduleListOptions.Expand, true);
            }
            if (jobScheduleListOptions?.MaxResults != null)
            {
                uri.AppendQuery("maxresults", jobScheduleListOptions.MaxResults.Value, true);
            }
            if (jobScheduleListOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", jobScheduleListOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (jobScheduleListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobScheduleListOptions.ClientRequestId.Value);
            }
            if (jobScheduleListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobScheduleListOptions.ReturnClientRequestId.Value);
            }
            if (jobScheduleListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobScheduleListOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Lists all of the Job Schedules in the specified Account. </summary>
        /// <param name="jobScheduleListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<CloudJobScheduleListResult, ListHeaders>> ListAsync(JobScheduleListOptions jobScheduleListOptions, CancellationToken cancellationToken = default)
        {
            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.List");
            scope.Start();
            try
            {
                using var message = CreateListRequest(jobScheduleListOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new ListHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            CloudJobScheduleListResult value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = CloudJobScheduleListResult.DeserializeCloudJobScheduleListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all of the Job Schedules in the specified Account. </summary>
        /// <param name="jobScheduleListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<CloudJobScheduleListResult, ListHeaders> List(JobScheduleListOptions jobScheduleListOptions, CancellationToken cancellationToken = default)
        {
            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.List");
            scope.Start();
            try
            {
                using var message = CreateListRequest(jobScheduleListOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new ListHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            CloudJobScheduleListResult value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = CloudJobScheduleListResult.DeserializeCloudJobScheduleListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateListNextPageRequest(string nextLink, JobScheduleListOptions jobScheduleListOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(nextLink, false);
            request.Uri = uri;
            if (jobScheduleListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", jobScheduleListOptions.ClientRequestId.Value);
            }
            if (jobScheduleListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", jobScheduleListOptions.ReturnClientRequestId.Value);
            }
            if (jobScheduleListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", jobScheduleListOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Lists all of the Job Schedules in the specified Account. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="jobScheduleListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<CloudJobScheduleListResult, ListHeaders>> ListNextPageAsync(string nextLink, JobScheduleListOptions jobScheduleListOptions, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.List");
            scope.Start();
            try
            {
                using var message = CreateListNextPageRequest(nextLink, jobScheduleListOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new ListHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            CloudJobScheduleListResult value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = CloudJobScheduleListResult.DeserializeCloudJobScheduleListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all of the Job Schedules in the specified Account. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="jobScheduleListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<CloudJobScheduleListResult, ListHeaders> ListNextPage(string nextLink, JobScheduleListOptions jobScheduleListOptions, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            using var scope = clientDiagnostics.CreateScope("JobScheduleClient.List");
            scope.Start();
            try
            {
                using var message = CreateListNextPageRequest(nextLink, jobScheduleListOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new ListHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            CloudJobScheduleListResult value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = CloudJobScheduleListResult.DeserializeCloudJobScheduleListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}
