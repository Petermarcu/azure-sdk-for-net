// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Batch.Models;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Batch
{
    internal partial class PoolRestClient
    {
        private string batchUrl;
        private string apiVersion;
        private ClientDiagnostics clientDiagnostics;
        private HttpPipeline pipeline;

        /// <summary> Initializes a new instance of PoolRestClient. </summary>
        public PoolRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string batchUrl, string apiVersion = "2020-03-01.11.0")
        {
            if (batchUrl == null)
            {
                throw new ArgumentNullException(nameof(batchUrl));
            }
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            this.batchUrl = batchUrl;
            this.apiVersion = apiVersion;
            this.clientDiagnostics = clientDiagnostics;
            this.pipeline = pipeline;
        }

        internal HttpMessage CreateListUsageMetricsRequest(PoolListUsageMetricsOptions poolListUsageMetricsOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/poolusagemetrics", false);
            if (poolListUsageMetricsOptions?.StartTime != null)
            {
                uri.AppendQuery("starttime", poolListUsageMetricsOptions.StartTime.Value, "S", true);
            }
            if (poolListUsageMetricsOptions?.EndTime != null)
            {
                uri.AppendQuery("endtime", poolListUsageMetricsOptions.EndTime.Value, "S", true);
            }
            if (poolListUsageMetricsOptions?.Filter != null)
            {
                uri.AppendQuery("$filter", poolListUsageMetricsOptions.Filter, true);
            }
            if (poolListUsageMetricsOptions?.MaxResults != null)
            {
                uri.AppendQuery("maxresults", poolListUsageMetricsOptions.MaxResults.Value, true);
            }
            if (poolListUsageMetricsOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolListUsageMetricsOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (poolListUsageMetricsOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolListUsageMetricsOptions.ClientRequestId.Value);
            }
            if (poolListUsageMetricsOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolListUsageMetricsOptions.ReturnClientRequestId.Value);
            }
            if (poolListUsageMetricsOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolListUsageMetricsOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including a startTime or endTime these filters default to the start and end times of the last aggregation interval currently available; that is, only the last aggregation interval is returned. </summary>
        /// <param name="poolListUsageMetricsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<PoolListUsageMetricsResult, ListUsageMetricsHeaders>> ListUsageMetricsAsync(PoolListUsageMetricsOptions poolListUsageMetricsOptions, CancellationToken cancellationToken = default)
        {
            using var scope = clientDiagnostics.CreateScope("PoolClient.ListUsageMetrics");
            scope.Start();
            try
            {
                using var message = CreateListUsageMetricsRequest(poolListUsageMetricsOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new ListUsageMetricsHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            PoolListUsageMetricsResult value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = PoolListUsageMetricsResult.DeserializePoolListUsageMetricsResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including a startTime or endTime these filters default to the start and end times of the last aggregation interval currently available; that is, only the last aggregation interval is returned. </summary>
        /// <param name="poolListUsageMetricsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<PoolListUsageMetricsResult, ListUsageMetricsHeaders> ListUsageMetrics(PoolListUsageMetricsOptions poolListUsageMetricsOptions, CancellationToken cancellationToken = default)
        {
            using var scope = clientDiagnostics.CreateScope("PoolClient.ListUsageMetrics");
            scope.Start();
            try
            {
                using var message = CreateListUsageMetricsRequest(poolListUsageMetricsOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new ListUsageMetricsHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            PoolListUsageMetricsResult value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = PoolListUsageMetricsResult.DeserializePoolListUsageMetricsResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetAllLifetimeStatisticsRequest(PoolGetAllLifetimeStatisticsOptions poolGetAllLifetimeStatisticsOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/lifetimepoolstats", false);
            if (poolGetAllLifetimeStatisticsOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolGetAllLifetimeStatisticsOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (poolGetAllLifetimeStatisticsOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolGetAllLifetimeStatisticsOptions.ClientRequestId.Value);
            }
            if (poolGetAllLifetimeStatisticsOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolGetAllLifetimeStatisticsOptions.ReturnClientRequestId.Value);
            }
            if (poolGetAllLifetimeStatisticsOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolGetAllLifetimeStatisticsOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Statistics are aggregated across all Pools that have ever existed in the Account, from Account creation to the last update time of the statistics. The statistics may not be immediately available. The Batch service performs periodic roll-up of statistics. The typical delay is about 30 minutes. </summary>
        /// <param name="poolGetAllLifetimeStatisticsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<PoolStatistics, GetAllLifetimeStatisticsHeaders>> GetAllLifetimeStatisticsAsync(PoolGetAllLifetimeStatisticsOptions poolGetAllLifetimeStatisticsOptions, CancellationToken cancellationToken = default)
        {
            using var scope = clientDiagnostics.CreateScope("PoolClient.GetAllLifetimeStatistics");
            scope.Start();
            try
            {
                using var message = CreateGetAllLifetimeStatisticsRequest(poolGetAllLifetimeStatisticsOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new GetAllLifetimeStatisticsHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            PoolStatistics value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = PoolStatistics.DeserializePoolStatistics(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Statistics are aggregated across all Pools that have ever existed in the Account, from Account creation to the last update time of the statistics. The statistics may not be immediately available. The Batch service performs periodic roll-up of statistics. The typical delay is about 30 minutes. </summary>
        /// <param name="poolGetAllLifetimeStatisticsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<PoolStatistics, GetAllLifetimeStatisticsHeaders> GetAllLifetimeStatistics(PoolGetAllLifetimeStatisticsOptions poolGetAllLifetimeStatisticsOptions, CancellationToken cancellationToken = default)
        {
            using var scope = clientDiagnostics.CreateScope("PoolClient.GetAllLifetimeStatistics");
            scope.Start();
            try
            {
                using var message = CreateGetAllLifetimeStatisticsRequest(poolGetAllLifetimeStatisticsOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new GetAllLifetimeStatisticsHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            PoolStatistics value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = PoolStatistics.DeserializePoolStatistics(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateAddRequest(PoolAddParameter pool, PoolAddOptions poolAddOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools", false);
            if (poolAddOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolAddOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (poolAddOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolAddOptions.ClientRequestId.Value);
            }
            if (poolAddOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolAddOptions.ReturnClientRequestId.Value);
            }
            if (poolAddOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolAddOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            using var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(pool);
            request.Content = content;
            return message;
        }

        /// <summary> When naming Pools, avoid including sensitive information such as user names or secret project names. This information may appear in telemetry logs accessible to Microsoft Support engineers. </summary>
        /// <param name="pool"> The Pool to be added. </param>
        /// <param name="poolAddOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<AddHeaders>> AddAsync(PoolAddParameter pool, PoolAddOptions poolAddOptions, CancellationToken cancellationToken = default)
        {
            if (pool == null)
            {
                throw new ArgumentNullException(nameof(pool));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.Add");
            scope.Start();
            try
            {
                using var message = CreateAddRequest(pool, poolAddOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new AddHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 201:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> When naming Pools, avoid including sensitive information such as user names or secret project names. This information may appear in telemetry logs accessible to Microsoft Support engineers. </summary>
        /// <param name="pool"> The Pool to be added. </param>
        /// <param name="poolAddOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<AddHeaders> Add(PoolAddParameter pool, PoolAddOptions poolAddOptions, CancellationToken cancellationToken = default)
        {
            if (pool == null)
            {
                throw new ArgumentNullException(nameof(pool));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.Add");
            scope.Start();
            try
            {
                using var message = CreateAddRequest(pool, poolAddOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new AddHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 201:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateListRequest(PoolListOptions poolListOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools", false);
            if (poolListOptions?.Filter != null)
            {
                uri.AppendQuery("$filter", poolListOptions.Filter, true);
            }
            if (poolListOptions?.Select != null)
            {
                uri.AppendQuery("$select", poolListOptions.Select, true);
            }
            if (poolListOptions?.Expand != null)
            {
                uri.AppendQuery("$expand", poolListOptions.Expand, true);
            }
            if (poolListOptions?.MaxResults != null)
            {
                uri.AppendQuery("maxresults", poolListOptions.MaxResults.Value, true);
            }
            if (poolListOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolListOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (poolListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolListOptions.ClientRequestId.Value);
            }
            if (poolListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolListOptions.ReturnClientRequestId.Value);
            }
            if (poolListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolListOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Lists all of the Pools in the specified Account. </summary>
        /// <param name="poolListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<CloudPoolListResult, ListHeaders>> ListAsync(PoolListOptions poolListOptions, CancellationToken cancellationToken = default)
        {
            using var scope = clientDiagnostics.CreateScope("PoolClient.List");
            scope.Start();
            try
            {
                using var message = CreateListRequest(poolListOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new ListHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            CloudPoolListResult value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = CloudPoolListResult.DeserializeCloudPoolListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all of the Pools in the specified Account. </summary>
        /// <param name="poolListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<CloudPoolListResult, ListHeaders> List(PoolListOptions poolListOptions, CancellationToken cancellationToken = default)
        {
            using var scope = clientDiagnostics.CreateScope("PoolClient.List");
            scope.Start();
            try
            {
                using var message = CreateListRequest(poolListOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new ListHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            CloudPoolListResult value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = CloudPoolListResult.DeserializeCloudPoolListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateDeleteRequest(string poolId, PoolDeleteOptions poolDeleteOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            if (poolDeleteOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolDeleteOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (poolDeleteOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolDeleteOptions.ClientRequestId.Value);
            }
            if (poolDeleteOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolDeleteOptions.ReturnClientRequestId.Value);
            }
            if (poolDeleteOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolDeleteOptions.OcpDate.Value, "R");
            }
            if (poolDeleteOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", poolDeleteOptions.IfMatch);
            }
            if (poolDeleteOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", poolDeleteOptions.IfNoneMatch);
            }
            if (poolDeleteOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", poolDeleteOptions.IfModifiedSince.Value, "R");
            }
            if (poolDeleteOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", poolDeleteOptions.IfUnmodifiedSince.Value, "R");
            }
            return message;
        }

        /// <summary> When you request that a Pool be deleted, the following actions occur: the Pool state is set to deleting; any ongoing resize operation on the Pool are stopped; the Batch service starts resizing the Pool to zero Compute Nodes; any Tasks running on existing Compute Nodes are terminated and requeued (as if a resize Pool operation had been requested with the default requeue option); finally, the Pool is removed from the system. Because running Tasks are requeued, the user can rerun these Tasks by updating their Job to target a different Pool. The Tasks can then run on the new Pool. If you want to override the requeue behavior, then you should call resize Pool explicitly to shrink the Pool to zero size before deleting the Pool. If you call an Update, Patch or Delete API on a Pool in the deleting state, it will fail with HTTP status code 409 with error code PoolBeingDeleted. </summary>
        /// <param name="poolId"> The ID of the Pool to delete. </param>
        /// <param name="poolDeleteOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<DeleteHeaders>> DeleteAsync(string poolId, PoolDeleteOptions poolDeleteOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.Delete");
            scope.Start();
            try
            {
                using var message = CreateDeleteRequest(poolId, poolDeleteOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new DeleteHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 202:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> When you request that a Pool be deleted, the following actions occur: the Pool state is set to deleting; any ongoing resize operation on the Pool are stopped; the Batch service starts resizing the Pool to zero Compute Nodes; any Tasks running on existing Compute Nodes are terminated and requeued (as if a resize Pool operation had been requested with the default requeue option); finally, the Pool is removed from the system. Because running Tasks are requeued, the user can rerun these Tasks by updating their Job to target a different Pool. The Tasks can then run on the new Pool. If you want to override the requeue behavior, then you should call resize Pool explicitly to shrink the Pool to zero size before deleting the Pool. If you call an Update, Patch or Delete API on a Pool in the deleting state, it will fail with HTTP status code 409 with error code PoolBeingDeleted. </summary>
        /// <param name="poolId"> The ID of the Pool to delete. </param>
        /// <param name="poolDeleteOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<DeleteHeaders> Delete(string poolId, PoolDeleteOptions poolDeleteOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.Delete");
            scope.Start();
            try
            {
                using var message = CreateDeleteRequest(poolId, poolDeleteOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new DeleteHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 202:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateExistsRequest(string poolId, PoolExistsOptions poolExistsOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            if (poolExistsOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolExistsOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (poolExistsOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolExistsOptions.ClientRequestId.Value);
            }
            if (poolExistsOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolExistsOptions.ReturnClientRequestId.Value);
            }
            if (poolExistsOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolExistsOptions.OcpDate.Value, "R");
            }
            if (poolExistsOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", poolExistsOptions.IfMatch);
            }
            if (poolExistsOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", poolExistsOptions.IfNoneMatch);
            }
            if (poolExistsOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", poolExistsOptions.IfModifiedSince.Value, "R");
            }
            if (poolExistsOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", poolExistsOptions.IfUnmodifiedSince.Value, "R");
            }
            return message;
        }

        /// <summary> Gets basic properties of a Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="poolExistsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<ExistsHeaders>> ExistsAsync(string poolId, PoolExistsOptions poolExistsOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.Exists");
            scope.Start();
            try
            {
                using var message = CreateExistsRequest(poolId, poolExistsOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new ExistsHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                    case 404:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets basic properties of a Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="poolExistsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<ExistsHeaders> Exists(string poolId, PoolExistsOptions poolExistsOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.Exists");
            scope.Start();
            try
            {
                using var message = CreateExistsRequest(poolId, poolExistsOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new ExistsHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                    case 404:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetRequest(string poolId, PoolGetOptions poolGetOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            if (poolGetOptions?.Select != null)
            {
                uri.AppendQuery("$select", poolGetOptions.Select, true);
            }
            if (poolGetOptions?.Expand != null)
            {
                uri.AppendQuery("$expand", poolGetOptions.Expand, true);
            }
            if (poolGetOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolGetOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (poolGetOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolGetOptions.ClientRequestId.Value);
            }
            if (poolGetOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolGetOptions.ReturnClientRequestId.Value);
            }
            if (poolGetOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolGetOptions.OcpDate.Value, "R");
            }
            if (poolGetOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", poolGetOptions.IfMatch);
            }
            if (poolGetOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", poolGetOptions.IfNoneMatch);
            }
            if (poolGetOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", poolGetOptions.IfModifiedSince.Value, "R");
            }
            if (poolGetOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", poolGetOptions.IfUnmodifiedSince.Value, "R");
            }
            return message;
        }

        /// <summary> Gets information about the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="poolGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<CloudPool, GetHeaders>> GetAsync(string poolId, PoolGetOptions poolGetOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.Get");
            scope.Start();
            try
            {
                using var message = CreateGetRequest(poolId, poolGetOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new GetHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            CloudPool value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = CloudPool.DeserializeCloudPool(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="poolGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<CloudPool, GetHeaders> Get(string poolId, PoolGetOptions poolGetOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.Get");
            scope.Start();
            try
            {
                using var message = CreateGetRequest(poolId, poolGetOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new GetHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            CloudPool value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = CloudPool.DeserializeCloudPool(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreatePatchRequest(string poolId, PoolPatchParameter poolPatchParameter, PoolPatchOptions poolPatchOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            if (poolPatchOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolPatchOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (poolPatchOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolPatchOptions.ClientRequestId.Value);
            }
            if (poolPatchOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolPatchOptions.ReturnClientRequestId.Value);
            }
            if (poolPatchOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolPatchOptions.OcpDate.Value, "R");
            }
            if (poolPatchOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", poolPatchOptions.IfMatch);
            }
            if (poolPatchOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", poolPatchOptions.IfNoneMatch);
            }
            if (poolPatchOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", poolPatchOptions.IfModifiedSince.Value, "R");
            }
            if (poolPatchOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", poolPatchOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            using var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(poolPatchParameter);
            request.Content = content;
            return message;
        }

        /// <summary> This only replaces the Pool properties specified in the request. For example, if the Pool has a StartTask associated with it, and a request does not specify a StartTask element, then the Pool keeps the existing StartTask. </summary>
        /// <param name="poolId"> The ID of the Pool to update. </param>
        /// <param name="poolPatchParameter"> The parameters for the request. </param>
        /// <param name="poolPatchOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<PatchHeaders>> PatchAsync(string poolId, PoolPatchParameter poolPatchParameter, PoolPatchOptions poolPatchOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolPatchParameter == null)
            {
                throw new ArgumentNullException(nameof(poolPatchParameter));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.Patch");
            scope.Start();
            try
            {
                using var message = CreatePatchRequest(poolId, poolPatchParameter, poolPatchOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new PatchHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This only replaces the Pool properties specified in the request. For example, if the Pool has a StartTask associated with it, and a request does not specify a StartTask element, then the Pool keeps the existing StartTask. </summary>
        /// <param name="poolId"> The ID of the Pool to update. </param>
        /// <param name="poolPatchParameter"> The parameters for the request. </param>
        /// <param name="poolPatchOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<PatchHeaders> Patch(string poolId, PoolPatchParameter poolPatchParameter, PoolPatchOptions poolPatchOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolPatchParameter == null)
            {
                throw new ArgumentNullException(nameof(poolPatchParameter));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.Patch");
            scope.Start();
            try
            {
                using var message = CreatePatchRequest(poolId, poolPatchParameter, poolPatchOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new PatchHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateDisableAutoScaleRequest(string poolId, PoolDisableAutoScaleOptions poolDisableAutoScaleOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/disableautoscale", false);
            if (poolDisableAutoScaleOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolDisableAutoScaleOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (poolDisableAutoScaleOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolDisableAutoScaleOptions.ClientRequestId.Value);
            }
            if (poolDisableAutoScaleOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolDisableAutoScaleOptions.ReturnClientRequestId.Value);
            }
            if (poolDisableAutoScaleOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolDisableAutoScaleOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Disables automatic scaling for a Pool. </summary>
        /// <param name="poolId"> The ID of the Pool on which to disable automatic scaling. </param>
        /// <param name="poolDisableAutoScaleOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<DisableAutoScaleHeaders>> DisableAutoScaleAsync(string poolId, PoolDisableAutoScaleOptions poolDisableAutoScaleOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.DisableAutoScale");
            scope.Start();
            try
            {
                using var message = CreateDisableAutoScaleRequest(poolId, poolDisableAutoScaleOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new DisableAutoScaleHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Disables automatic scaling for a Pool. </summary>
        /// <param name="poolId"> The ID of the Pool on which to disable automatic scaling. </param>
        /// <param name="poolDisableAutoScaleOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<DisableAutoScaleHeaders> DisableAutoScale(string poolId, PoolDisableAutoScaleOptions poolDisableAutoScaleOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.DisableAutoScale");
            scope.Start();
            try
            {
                using var message = CreateDisableAutoScaleRequest(poolId, poolDisableAutoScaleOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new DisableAutoScaleHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateEnableAutoScaleRequest(string poolId, PoolEnableAutoScaleParameter poolEnableAutoScaleParameter, PoolEnableAutoScaleOptions poolEnableAutoScaleOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/enableautoscale", false);
            if (poolEnableAutoScaleOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolEnableAutoScaleOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (poolEnableAutoScaleOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolEnableAutoScaleOptions.ClientRequestId.Value);
            }
            if (poolEnableAutoScaleOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolEnableAutoScaleOptions.ReturnClientRequestId.Value);
            }
            if (poolEnableAutoScaleOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolEnableAutoScaleOptions.OcpDate.Value, "R");
            }
            if (poolEnableAutoScaleOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", poolEnableAutoScaleOptions.IfMatch);
            }
            if (poolEnableAutoScaleOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", poolEnableAutoScaleOptions.IfNoneMatch);
            }
            if (poolEnableAutoScaleOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", poolEnableAutoScaleOptions.IfModifiedSince.Value, "R");
            }
            if (poolEnableAutoScaleOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", poolEnableAutoScaleOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            using var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(poolEnableAutoScaleParameter);
            request.Content = content;
            return message;
        }

        /// <summary> You cannot enable automatic scaling on a Pool if a resize operation is in progress on the Pool. If automatic scaling of the Pool is currently disabled, you must specify a valid autoscale formula as part of the request. If automatic scaling of the Pool is already enabled, you may specify a new autoscale formula and/or a new evaluation interval. You cannot call this API for the same Pool more than once every 30 seconds. </summary>
        /// <param name="poolId"> The ID of the Pool on which to enable automatic scaling. </param>
        /// <param name="poolEnableAutoScaleParameter"> The parameters for the request. </param>
        /// <param name="poolEnableAutoScaleOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<EnableAutoScaleHeaders>> EnableAutoScaleAsync(string poolId, PoolEnableAutoScaleParameter poolEnableAutoScaleParameter, PoolEnableAutoScaleOptions poolEnableAutoScaleOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolEnableAutoScaleParameter == null)
            {
                throw new ArgumentNullException(nameof(poolEnableAutoScaleParameter));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.EnableAutoScale");
            scope.Start();
            try
            {
                using var message = CreateEnableAutoScaleRequest(poolId, poolEnableAutoScaleParameter, poolEnableAutoScaleOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new EnableAutoScaleHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You cannot enable automatic scaling on a Pool if a resize operation is in progress on the Pool. If automatic scaling of the Pool is currently disabled, you must specify a valid autoscale formula as part of the request. If automatic scaling of the Pool is already enabled, you may specify a new autoscale formula and/or a new evaluation interval. You cannot call this API for the same Pool more than once every 30 seconds. </summary>
        /// <param name="poolId"> The ID of the Pool on which to enable automatic scaling. </param>
        /// <param name="poolEnableAutoScaleParameter"> The parameters for the request. </param>
        /// <param name="poolEnableAutoScaleOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<EnableAutoScaleHeaders> EnableAutoScale(string poolId, PoolEnableAutoScaleParameter poolEnableAutoScaleParameter, PoolEnableAutoScaleOptions poolEnableAutoScaleOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolEnableAutoScaleParameter == null)
            {
                throw new ArgumentNullException(nameof(poolEnableAutoScaleParameter));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.EnableAutoScale");
            scope.Start();
            try
            {
                using var message = CreateEnableAutoScaleRequest(poolId, poolEnableAutoScaleParameter, poolEnableAutoScaleOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new EnableAutoScaleHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateEvaluateAutoScaleRequest(string poolId, PoolEvaluateAutoScaleParameter poolEvaluateAutoScaleParameter, PoolEvaluateAutoScaleOptions poolEvaluateAutoScaleOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/evaluateautoscale", false);
            if (poolEvaluateAutoScaleOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolEvaluateAutoScaleOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (poolEvaluateAutoScaleOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolEvaluateAutoScaleOptions.ClientRequestId.Value);
            }
            if (poolEvaluateAutoScaleOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolEvaluateAutoScaleOptions.ReturnClientRequestId.Value);
            }
            if (poolEvaluateAutoScaleOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolEvaluateAutoScaleOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            using var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(poolEvaluateAutoScaleParameter);
            request.Content = content;
            return message;
        }

        /// <summary> This API is primarily for validating an autoscale formula, as it simply returns the result without applying the formula to the Pool. The Pool must have auto scaling enabled in order to evaluate a formula. </summary>
        /// <param name="poolId"> The ID of the Pool on which to evaluate the automatic scaling formula. </param>
        /// <param name="poolEvaluateAutoScaleParameter"> The parameters for the request. </param>
        /// <param name="poolEvaluateAutoScaleOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<AutoScaleRun, EvaluateAutoScaleHeaders>> EvaluateAutoScaleAsync(string poolId, PoolEvaluateAutoScaleParameter poolEvaluateAutoScaleParameter, PoolEvaluateAutoScaleOptions poolEvaluateAutoScaleOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolEvaluateAutoScaleParameter == null)
            {
                throw new ArgumentNullException(nameof(poolEvaluateAutoScaleParameter));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.EvaluateAutoScale");
            scope.Start();
            try
            {
                using var message = CreateEvaluateAutoScaleRequest(poolId, poolEvaluateAutoScaleParameter, poolEvaluateAutoScaleOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new EvaluateAutoScaleHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            AutoScaleRun value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = AutoScaleRun.DeserializeAutoScaleRun(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This API is primarily for validating an autoscale formula, as it simply returns the result without applying the formula to the Pool. The Pool must have auto scaling enabled in order to evaluate a formula. </summary>
        /// <param name="poolId"> The ID of the Pool on which to evaluate the automatic scaling formula. </param>
        /// <param name="poolEvaluateAutoScaleParameter"> The parameters for the request. </param>
        /// <param name="poolEvaluateAutoScaleOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<AutoScaleRun, EvaluateAutoScaleHeaders> EvaluateAutoScale(string poolId, PoolEvaluateAutoScaleParameter poolEvaluateAutoScaleParameter, PoolEvaluateAutoScaleOptions poolEvaluateAutoScaleOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolEvaluateAutoScaleParameter == null)
            {
                throw new ArgumentNullException(nameof(poolEvaluateAutoScaleParameter));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.EvaluateAutoScale");
            scope.Start();
            try
            {
                using var message = CreateEvaluateAutoScaleRequest(poolId, poolEvaluateAutoScaleParameter, poolEvaluateAutoScaleOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new EvaluateAutoScaleHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            AutoScaleRun value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = AutoScaleRun.DeserializeAutoScaleRun(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateResizeRequest(string poolId, PoolResizeParameter poolResizeParameter, PoolResizeOptions poolResizeOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/resize", false);
            if (poolResizeOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolResizeOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (poolResizeOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolResizeOptions.ClientRequestId.Value);
            }
            if (poolResizeOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolResizeOptions.ReturnClientRequestId.Value);
            }
            if (poolResizeOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolResizeOptions.OcpDate.Value, "R");
            }
            if (poolResizeOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", poolResizeOptions.IfMatch);
            }
            if (poolResizeOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", poolResizeOptions.IfNoneMatch);
            }
            if (poolResizeOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", poolResizeOptions.IfModifiedSince.Value, "R");
            }
            if (poolResizeOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", poolResizeOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            using var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(poolResizeParameter);
            request.Content = content;
            return message;
        }

        /// <summary> You can only resize a Pool when its allocation state is steady. If the Pool is already resizing, the request fails with status code 409. When you resize a Pool, the Pool&apos;s allocation state changes from steady to resizing. You cannot resize Pools which are configured for automatic scaling. If you try to do this, the Batch service returns an error 409. If you resize a Pool downwards, the Batch service chooses which Compute Nodes to remove. To remove specific Compute Nodes, use the Pool remove Compute Nodes API instead. </summary>
        /// <param name="poolId"> The ID of the Pool to resize. </param>
        /// <param name="poolResizeParameter"> The parameters for the request. </param>
        /// <param name="poolResizeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<ResizeHeaders>> ResizeAsync(string poolId, PoolResizeParameter poolResizeParameter, PoolResizeOptions poolResizeOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolResizeParameter == null)
            {
                throw new ArgumentNullException(nameof(poolResizeParameter));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.Resize");
            scope.Start();
            try
            {
                using var message = CreateResizeRequest(poolId, poolResizeParameter, poolResizeOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new ResizeHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 202:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can only resize a Pool when its allocation state is steady. If the Pool is already resizing, the request fails with status code 409. When you resize a Pool, the Pool&apos;s allocation state changes from steady to resizing. You cannot resize Pools which are configured for automatic scaling. If you try to do this, the Batch service returns an error 409. If you resize a Pool downwards, the Batch service chooses which Compute Nodes to remove. To remove specific Compute Nodes, use the Pool remove Compute Nodes API instead. </summary>
        /// <param name="poolId"> The ID of the Pool to resize. </param>
        /// <param name="poolResizeParameter"> The parameters for the request. </param>
        /// <param name="poolResizeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<ResizeHeaders> Resize(string poolId, PoolResizeParameter poolResizeParameter, PoolResizeOptions poolResizeOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolResizeParameter == null)
            {
                throw new ArgumentNullException(nameof(poolResizeParameter));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.Resize");
            scope.Start();
            try
            {
                using var message = CreateResizeRequest(poolId, poolResizeParameter, poolResizeOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new ResizeHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 202:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateStopResizeRequest(string poolId, PoolStopResizeOptions poolStopResizeOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/stopresize", false);
            if (poolStopResizeOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolStopResizeOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (poolStopResizeOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolStopResizeOptions.ClientRequestId.Value);
            }
            if (poolStopResizeOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolStopResizeOptions.ReturnClientRequestId.Value);
            }
            if (poolStopResizeOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolStopResizeOptions.OcpDate.Value, "R");
            }
            if (poolStopResizeOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", poolStopResizeOptions.IfMatch);
            }
            if (poolStopResizeOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", poolStopResizeOptions.IfNoneMatch);
            }
            if (poolStopResizeOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", poolStopResizeOptions.IfModifiedSince.Value, "R");
            }
            if (poolStopResizeOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", poolStopResizeOptions.IfUnmodifiedSince.Value, "R");
            }
            return message;
        }

        /// <summary> This does not restore the Pool to its previous state before the resize operation: it only stops any further changes being made, and the Pool maintains its current state. After stopping, the Pool stabilizes at the number of Compute Nodes it was at when the stop operation was done. During the stop operation, the Pool allocation state changes first to stopping and then to steady. A resize operation need not be an explicit resize Pool request; this API can also be used to halt the initial sizing of the Pool when it is created. </summary>
        /// <param name="poolId"> The ID of the Pool whose resizing you want to stop. </param>
        /// <param name="poolStopResizeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<StopResizeHeaders>> StopResizeAsync(string poolId, PoolStopResizeOptions poolStopResizeOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.StopResize");
            scope.Start();
            try
            {
                using var message = CreateStopResizeRequest(poolId, poolStopResizeOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new StopResizeHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 202:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This does not restore the Pool to its previous state before the resize operation: it only stops any further changes being made, and the Pool maintains its current state. After stopping, the Pool stabilizes at the number of Compute Nodes it was at when the stop operation was done. During the stop operation, the Pool allocation state changes first to stopping and then to steady. A resize operation need not be an explicit resize Pool request; this API can also be used to halt the initial sizing of the Pool when it is created. </summary>
        /// <param name="poolId"> The ID of the Pool whose resizing you want to stop. </param>
        /// <param name="poolStopResizeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<StopResizeHeaders> StopResize(string poolId, PoolStopResizeOptions poolStopResizeOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.StopResize");
            scope.Start();
            try
            {
                using var message = CreateStopResizeRequest(poolId, poolStopResizeOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new StopResizeHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 202:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateUpdatePropertiesRequest(string poolId, PoolUpdatePropertiesParameter poolUpdatePropertiesParameter, PoolUpdatePropertiesOptions poolUpdatePropertiesOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/updateproperties", false);
            if (poolUpdatePropertiesOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolUpdatePropertiesOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (poolUpdatePropertiesOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolUpdatePropertiesOptions.ClientRequestId.Value);
            }
            if (poolUpdatePropertiesOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolUpdatePropertiesOptions.ReturnClientRequestId.Value);
            }
            if (poolUpdatePropertiesOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolUpdatePropertiesOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            using var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(poolUpdatePropertiesParameter);
            request.Content = content;
            return message;
        }

        /// <summary> This fully replaces all the updatable properties of the Pool. For example, if the Pool has a StartTask associated with it and if StartTask is not specified with this request, then the Batch service will remove the existing StartTask. </summary>
        /// <param name="poolId"> The ID of the Pool to update. </param>
        /// <param name="poolUpdatePropertiesParameter"> The parameters for the request. </param>
        /// <param name="poolUpdatePropertiesOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<UpdatePropertiesHeaders>> UpdatePropertiesAsync(string poolId, PoolUpdatePropertiesParameter poolUpdatePropertiesParameter, PoolUpdatePropertiesOptions poolUpdatePropertiesOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolUpdatePropertiesParameter == null)
            {
                throw new ArgumentNullException(nameof(poolUpdatePropertiesParameter));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.UpdateProperties");
            scope.Start();
            try
            {
                using var message = CreateUpdatePropertiesRequest(poolId, poolUpdatePropertiesParameter, poolUpdatePropertiesOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new UpdatePropertiesHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 204:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This fully replaces all the updatable properties of the Pool. For example, if the Pool has a StartTask associated with it and if StartTask is not specified with this request, then the Batch service will remove the existing StartTask. </summary>
        /// <param name="poolId"> The ID of the Pool to update. </param>
        /// <param name="poolUpdatePropertiesParameter"> The parameters for the request. </param>
        /// <param name="poolUpdatePropertiesOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<UpdatePropertiesHeaders> UpdateProperties(string poolId, PoolUpdatePropertiesParameter poolUpdatePropertiesParameter, PoolUpdatePropertiesOptions poolUpdatePropertiesOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (poolUpdatePropertiesParameter == null)
            {
                throw new ArgumentNullException(nameof(poolUpdatePropertiesParameter));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.UpdateProperties");
            scope.Start();
            try
            {
                using var message = CreateUpdatePropertiesRequest(poolId, poolUpdatePropertiesParameter, poolUpdatePropertiesOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new UpdatePropertiesHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 204:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateRemoveNodesRequest(string poolId, NodeRemoveParameter nodeRemoveParameter, PoolRemoveNodesOptions poolRemoveNodesOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/removenodes", false);
            if (poolRemoveNodesOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", poolRemoveNodesOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (poolRemoveNodesOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolRemoveNodesOptions.ClientRequestId.Value);
            }
            if (poolRemoveNodesOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolRemoveNodesOptions.ReturnClientRequestId.Value);
            }
            if (poolRemoveNodesOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolRemoveNodesOptions.OcpDate.Value, "R");
            }
            if (poolRemoveNodesOptions?.IfMatch != null)
            {
                request.Headers.Add("If-Match", poolRemoveNodesOptions.IfMatch);
            }
            if (poolRemoveNodesOptions?.IfNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", poolRemoveNodesOptions.IfNoneMatch);
            }
            if (poolRemoveNodesOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", poolRemoveNodesOptions.IfModifiedSince.Value, "R");
            }
            if (poolRemoveNodesOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", poolRemoveNodesOptions.IfUnmodifiedSince.Value, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            using var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(nodeRemoveParameter);
            request.Content = content;
            return message;
        }

        /// <summary> This operation can only run when the allocation state of the Pool is steady. When this operation runs, the allocation state changes from steady to resizing. </summary>
        /// <param name="poolId"> The ID of the Pool from which you want to remove Compute Nodes. </param>
        /// <param name="nodeRemoveParameter"> The parameters for the request. </param>
        /// <param name="poolRemoveNodesOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<RemoveNodesHeaders>> RemoveNodesAsync(string poolId, NodeRemoveParameter nodeRemoveParameter, PoolRemoveNodesOptions poolRemoveNodesOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeRemoveParameter == null)
            {
                throw new ArgumentNullException(nameof(nodeRemoveParameter));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.RemoveNodes");
            scope.Start();
            try
            {
                using var message = CreateRemoveNodesRequest(poolId, nodeRemoveParameter, poolRemoveNodesOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new RemoveNodesHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 202:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This operation can only run when the allocation state of the Pool is steady. When this operation runs, the allocation state changes from steady to resizing. </summary>
        /// <param name="poolId"> The ID of the Pool from which you want to remove Compute Nodes. </param>
        /// <param name="nodeRemoveParameter"> The parameters for the request. </param>
        /// <param name="poolRemoveNodesOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<RemoveNodesHeaders> RemoveNodes(string poolId, NodeRemoveParameter nodeRemoveParameter, PoolRemoveNodesOptions poolRemoveNodesOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeRemoveParameter == null)
            {
                throw new ArgumentNullException(nameof(nodeRemoveParameter));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.RemoveNodes");
            scope.Start();
            try
            {
                using var message = CreateRemoveNodesRequest(poolId, nodeRemoveParameter, poolRemoveNodesOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new RemoveNodesHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 202:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateListUsageMetricsNextPageRequest(string nextLink, PoolListUsageMetricsOptions poolListUsageMetricsOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(nextLink, false);
            request.Uri = uri;
            if (poolListUsageMetricsOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolListUsageMetricsOptions.ClientRequestId.Value);
            }
            if (poolListUsageMetricsOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolListUsageMetricsOptions.ReturnClientRequestId.Value);
            }
            if (poolListUsageMetricsOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolListUsageMetricsOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including a startTime or endTime these filters default to the start and end times of the last aggregation interval currently available; that is, only the last aggregation interval is returned. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="poolListUsageMetricsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<PoolListUsageMetricsResult, ListUsageMetricsHeaders>> ListUsageMetricsNextPageAsync(string nextLink, PoolListUsageMetricsOptions poolListUsageMetricsOptions, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.ListUsageMetrics");
            scope.Start();
            try
            {
                using var message = CreateListUsageMetricsNextPageRequest(nextLink, poolListUsageMetricsOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new ListUsageMetricsHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            PoolListUsageMetricsResult value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = PoolListUsageMetricsResult.DeserializePoolListUsageMetricsResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including a startTime or endTime these filters default to the start and end times of the last aggregation interval currently available; that is, only the last aggregation interval is returned. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="poolListUsageMetricsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<PoolListUsageMetricsResult, ListUsageMetricsHeaders> ListUsageMetricsNextPage(string nextLink, PoolListUsageMetricsOptions poolListUsageMetricsOptions, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.ListUsageMetrics");
            scope.Start();
            try
            {
                using var message = CreateListUsageMetricsNextPageRequest(nextLink, poolListUsageMetricsOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new ListUsageMetricsHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            PoolListUsageMetricsResult value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = PoolListUsageMetricsResult.DeserializePoolListUsageMetricsResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateListNextPageRequest(string nextLink, PoolListOptions poolListOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(nextLink, false);
            request.Uri = uri;
            if (poolListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", poolListOptions.ClientRequestId.Value);
            }
            if (poolListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", poolListOptions.ReturnClientRequestId.Value);
            }
            if (poolListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", poolListOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Lists all of the Pools in the specified Account. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="poolListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<CloudPoolListResult, ListHeaders>> ListNextPageAsync(string nextLink, PoolListOptions poolListOptions, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.List");
            scope.Start();
            try
            {
                using var message = CreateListNextPageRequest(nextLink, poolListOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new ListHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            CloudPoolListResult value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = CloudPoolListResult.DeserializeCloudPoolListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all of the Pools in the specified Account. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="poolListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<CloudPoolListResult, ListHeaders> ListNextPage(string nextLink, PoolListOptions poolListOptions, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }

            using var scope = clientDiagnostics.CreateScope("PoolClient.List");
            scope.Start();
            try
            {
                using var message = CreateListNextPageRequest(nextLink, poolListOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new ListHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            CloudPoolListResult value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = CloudPoolListResult.DeserializeCloudPoolListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}
