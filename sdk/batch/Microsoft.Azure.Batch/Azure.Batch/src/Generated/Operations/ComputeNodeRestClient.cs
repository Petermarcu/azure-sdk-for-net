// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.IO;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Batch.Models;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Batch
{
    internal partial class ComputeNodeRestClient
    {
        private string batchUrl;
        private string apiVersion;
        private ClientDiagnostics clientDiagnostics;
        private HttpPipeline pipeline;

        /// <summary> Initializes a new instance of ComputeNodeRestClient. </summary>
        public ComputeNodeRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string batchUrl, string apiVersion = "2020-03-01.11.0")
        {
            if (batchUrl == null)
            {
                throw new ArgumentNullException(nameof(batchUrl));
            }
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            this.batchUrl = batchUrl;
            this.apiVersion = apiVersion;
            this.clientDiagnostics = clientDiagnostics;
            this.pipeline = pipeline;
        }

        internal HttpMessage CreateAddUserRequest(string poolId, string nodeId, ComputeNodeUser user, ComputeNodeAddUserOptions computeNodeAddUserOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/users", false);
            if (computeNodeAddUserOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeAddUserOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (computeNodeAddUserOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeAddUserOptions.ClientRequestId.Value);
            }
            if (computeNodeAddUserOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeAddUserOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeAddUserOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeAddUserOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            using var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(user);
            request.Content = content;
            return message;
        }

        /// <summary> You can add a user Account to a Compute Node only when it is in the idle or running state. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to create a user Account. </param>
        /// <param name="user"> The user Account to be created. </param>
        /// <param name="computeNodeAddUserOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<AddUserHeaders>> AddUserAsync(string poolId, string nodeId, ComputeNodeUser user, ComputeNodeAddUserOptions computeNodeAddUserOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.AddUser");
            scope.Start();
            try
            {
                using var message = CreateAddUserRequest(poolId, nodeId, user, computeNodeAddUserOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new AddUserHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 201:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can add a user Account to a Compute Node only when it is in the idle or running state. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to create a user Account. </param>
        /// <param name="user"> The user Account to be created. </param>
        /// <param name="computeNodeAddUserOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<AddUserHeaders> AddUser(string poolId, string nodeId, ComputeNodeUser user, ComputeNodeAddUserOptions computeNodeAddUserOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.AddUser");
            scope.Start();
            try
            {
                using var message = CreateAddUserRequest(poolId, nodeId, user, computeNodeAddUserOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new AddUserHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 201:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateDeleteUserRequest(string poolId, string nodeId, string userName, ComputeNodeDeleteUserOptions computeNodeDeleteUserOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/users/", false);
            uri.AppendPath(userName, true);
            if (computeNodeDeleteUserOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeDeleteUserOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (computeNodeDeleteUserOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeDeleteUserOptions.ClientRequestId.Value);
            }
            if (computeNodeDeleteUserOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeDeleteUserOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeDeleteUserOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeDeleteUserOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> You can delete a user Account to a Compute Node only when it is in the idle or running state. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to delete a user Account. </param>
        /// <param name="userName"> The name of the user Account to delete. </param>
        /// <param name="computeNodeDeleteUserOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<DeleteUserHeaders>> DeleteUserAsync(string poolId, string nodeId, string userName, ComputeNodeDeleteUserOptions computeNodeDeleteUserOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (userName == null)
            {
                throw new ArgumentNullException(nameof(userName));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.DeleteUser");
            scope.Start();
            try
            {
                using var message = CreateDeleteUserRequest(poolId, nodeId, userName, computeNodeDeleteUserOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new DeleteUserHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can delete a user Account to a Compute Node only when it is in the idle or running state. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to delete a user Account. </param>
        /// <param name="userName"> The name of the user Account to delete. </param>
        /// <param name="computeNodeDeleteUserOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<DeleteUserHeaders> DeleteUser(string poolId, string nodeId, string userName, ComputeNodeDeleteUserOptions computeNodeDeleteUserOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (userName == null)
            {
                throw new ArgumentNullException(nameof(userName));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.DeleteUser");
            scope.Start();
            try
            {
                using var message = CreateDeleteUserRequest(poolId, nodeId, userName, computeNodeDeleteUserOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new DeleteUserHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateUpdateUserRequest(string poolId, string nodeId, string userName, NodeUpdateUserParameter nodeUpdateUserParameter, ComputeNodeUpdateUserOptions computeNodeUpdateUserOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/users/", false);
            uri.AppendPath(userName, true);
            if (computeNodeUpdateUserOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeUpdateUserOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (computeNodeUpdateUserOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeUpdateUserOptions.ClientRequestId.Value);
            }
            if (computeNodeUpdateUserOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeUpdateUserOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeUpdateUserOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeUpdateUserOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            using var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(nodeUpdateUserParameter);
            request.Content = content;
            return message;
        }

        /// <summary> This operation replaces of all the updatable properties of the Account. For example, if the expiryTime element is not specified, the current value is replaced with the default value, not left unmodified. You can update a user Account on a Compute Node only when it is in the idle or running state. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to update a user Account. </param>
        /// <param name="userName"> The name of the user Account to update. </param>
        /// <param name="nodeUpdateUserParameter"> The parameters for the request. </param>
        /// <param name="computeNodeUpdateUserOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<UpdateUserHeaders>> UpdateUserAsync(string poolId, string nodeId, string userName, NodeUpdateUserParameter nodeUpdateUserParameter, ComputeNodeUpdateUserOptions computeNodeUpdateUserOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (userName == null)
            {
                throw new ArgumentNullException(nameof(userName));
            }
            if (nodeUpdateUserParameter == null)
            {
                throw new ArgumentNullException(nameof(nodeUpdateUserParameter));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.UpdateUser");
            scope.Start();
            try
            {
                using var message = CreateUpdateUserRequest(poolId, nodeId, userName, nodeUpdateUserParameter, computeNodeUpdateUserOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new UpdateUserHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This operation replaces of all the updatable properties of the Account. For example, if the expiryTime element is not specified, the current value is replaced with the default value, not left unmodified. You can update a user Account on a Compute Node only when it is in the idle or running state. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to update a user Account. </param>
        /// <param name="userName"> The name of the user Account to update. </param>
        /// <param name="nodeUpdateUserParameter"> The parameters for the request. </param>
        /// <param name="computeNodeUpdateUserOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<UpdateUserHeaders> UpdateUser(string poolId, string nodeId, string userName, NodeUpdateUserParameter nodeUpdateUserParameter, ComputeNodeUpdateUserOptions computeNodeUpdateUserOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (userName == null)
            {
                throw new ArgumentNullException(nameof(userName));
            }
            if (nodeUpdateUserParameter == null)
            {
                throw new ArgumentNullException(nameof(nodeUpdateUserParameter));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.UpdateUser");
            scope.Start();
            try
            {
                using var message = CreateUpdateUserRequest(poolId, nodeId, userName, nodeUpdateUserParameter, computeNodeUpdateUserOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new UpdateUserHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetRequest(string poolId, string nodeId, ComputeNodeGetOptions computeNodeGetOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            if (computeNodeGetOptions?.Select != null)
            {
                uri.AppendQuery("$select", computeNodeGetOptions.Select, true);
            }
            if (computeNodeGetOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeGetOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (computeNodeGetOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeGetOptions.ClientRequestId.Value);
            }
            if (computeNodeGetOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeGetOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeGetOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeGetOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Gets information about the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to get information about. </param>
        /// <param name="computeNodeGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<ComputeNode, GetHeaders>> GetAsync(string poolId, string nodeId, ComputeNodeGetOptions computeNodeGetOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.Get");
            scope.Start();
            try
            {
                using var message = CreateGetRequest(poolId, nodeId, computeNodeGetOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new GetHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            ComputeNode value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = ComputeNode.DeserializeComputeNode(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to get information about. </param>
        /// <param name="computeNodeGetOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<ComputeNode, GetHeaders> Get(string poolId, string nodeId, ComputeNodeGetOptions computeNodeGetOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.Get");
            scope.Start();
            try
            {
                using var message = CreateGetRequest(poolId, nodeId, computeNodeGetOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new GetHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            ComputeNode value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = ComputeNode.DeserializeComputeNode(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateRebootRequest(string poolId, string nodeId, NodeRebootParameter nodeRebootParameter, ComputeNodeRebootOptions computeNodeRebootOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/reboot", false);
            if (computeNodeRebootOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeRebootOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (computeNodeRebootOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeRebootOptions.ClientRequestId.Value);
            }
            if (computeNodeRebootOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeRebootOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeRebootOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeRebootOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            if (nodeRebootParameter != null)
            {
                using var content = new Utf8JsonRequestContent();
                content.JsonWriter.WriteObjectValue(nodeRebootParameter);
                request.Content = content;
            }
            return message;
        }

        /// <summary> You can restart a Compute Node only if it is in an idle or running state. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="nodeRebootParameter"> The parameters for the request. </param>
        /// <param name="computeNodeRebootOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<RebootHeaders>> RebootAsync(string poolId, string nodeId, NodeRebootParameter nodeRebootParameter, ComputeNodeRebootOptions computeNodeRebootOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.Reboot");
            scope.Start();
            try
            {
                using var message = CreateRebootRequest(poolId, nodeId, nodeRebootParameter, computeNodeRebootOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new RebootHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 202:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can restart a Compute Node only if it is in an idle or running state. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="nodeRebootParameter"> The parameters for the request. </param>
        /// <param name="computeNodeRebootOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<RebootHeaders> Reboot(string poolId, string nodeId, NodeRebootParameter nodeRebootParameter, ComputeNodeRebootOptions computeNodeRebootOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.Reboot");
            scope.Start();
            try
            {
                using var message = CreateRebootRequest(poolId, nodeId, nodeRebootParameter, computeNodeRebootOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new RebootHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 202:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateReimageRequest(string poolId, string nodeId, NodeReimageParameter nodeReimageParameter, ComputeNodeReimageOptions computeNodeReimageOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/reimage", false);
            if (computeNodeReimageOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeReimageOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (computeNodeReimageOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeReimageOptions.ClientRequestId.Value);
            }
            if (computeNodeReimageOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeReimageOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeReimageOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeReimageOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            if (nodeReimageParameter != null)
            {
                using var content = new Utf8JsonRequestContent();
                content.JsonWriter.WriteObjectValue(nodeReimageParameter);
                request.Content = content;
            }
            return message;
        }

        /// <summary> You can reinstall the operating system on a Compute Node only if it is in an idle or running state. This API can be invoked only on Pools created with the cloud service configuration property. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="nodeReimageParameter"> The parameters for the request. </param>
        /// <param name="computeNodeReimageOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<ReimageHeaders>> ReimageAsync(string poolId, string nodeId, NodeReimageParameter nodeReimageParameter, ComputeNodeReimageOptions computeNodeReimageOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.Reimage");
            scope.Start();
            try
            {
                using var message = CreateReimageRequest(poolId, nodeId, nodeReimageParameter, computeNodeReimageOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new ReimageHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 202:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can reinstall the operating system on a Compute Node only if it is in an idle or running state. This API can be invoked only on Pools created with the cloud service configuration property. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="nodeReimageParameter"> The parameters for the request. </param>
        /// <param name="computeNodeReimageOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<ReimageHeaders> Reimage(string poolId, string nodeId, NodeReimageParameter nodeReimageParameter, ComputeNodeReimageOptions computeNodeReimageOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.Reimage");
            scope.Start();
            try
            {
                using var message = CreateReimageRequest(poolId, nodeId, nodeReimageParameter, computeNodeReimageOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new ReimageHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 202:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateDisableSchedulingRequest(string poolId, string nodeId, NodeDisableSchedulingParameter nodeDisableSchedulingParameter, ComputeNodeDisableSchedulingOptions computeNodeDisableSchedulingOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/disablescheduling", false);
            if (computeNodeDisableSchedulingOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeDisableSchedulingOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (computeNodeDisableSchedulingOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeDisableSchedulingOptions.ClientRequestId.Value);
            }
            if (computeNodeDisableSchedulingOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeDisableSchedulingOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeDisableSchedulingOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeDisableSchedulingOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            if (nodeDisableSchedulingParameter != null)
            {
                using var content = new Utf8JsonRequestContent();
                content.JsonWriter.WriteObjectValue(nodeDisableSchedulingParameter);
                request.Content = content;
            }
            return message;
        }

        /// <summary> You can disable Task scheduling on a Compute Node only if its current scheduling state is enabled. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node on which you want to disable Task scheduling. </param>
        /// <param name="nodeDisableSchedulingParameter"> The parameters for the request. </param>
        /// <param name="computeNodeDisableSchedulingOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<DisableSchedulingHeaders>> DisableSchedulingAsync(string poolId, string nodeId, NodeDisableSchedulingParameter nodeDisableSchedulingParameter, ComputeNodeDisableSchedulingOptions computeNodeDisableSchedulingOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.DisableScheduling");
            scope.Start();
            try
            {
                using var message = CreateDisableSchedulingRequest(poolId, nodeId, nodeDisableSchedulingParameter, computeNodeDisableSchedulingOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new DisableSchedulingHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can disable Task scheduling on a Compute Node only if its current scheduling state is enabled. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node on which you want to disable Task scheduling. </param>
        /// <param name="nodeDisableSchedulingParameter"> The parameters for the request. </param>
        /// <param name="computeNodeDisableSchedulingOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<DisableSchedulingHeaders> DisableScheduling(string poolId, string nodeId, NodeDisableSchedulingParameter nodeDisableSchedulingParameter, ComputeNodeDisableSchedulingOptions computeNodeDisableSchedulingOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.DisableScheduling");
            scope.Start();
            try
            {
                using var message = CreateDisableSchedulingRequest(poolId, nodeId, nodeDisableSchedulingParameter, computeNodeDisableSchedulingOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new DisableSchedulingHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateEnableSchedulingRequest(string poolId, string nodeId, ComputeNodeEnableSchedulingOptions computeNodeEnableSchedulingOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/enablescheduling", false);
            if (computeNodeEnableSchedulingOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeEnableSchedulingOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (computeNodeEnableSchedulingOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeEnableSchedulingOptions.ClientRequestId.Value);
            }
            if (computeNodeEnableSchedulingOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeEnableSchedulingOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeEnableSchedulingOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeEnableSchedulingOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> You can enable Task scheduling on a Compute Node only if its current scheduling state is disabled. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node on which you want to enable Task scheduling. </param>
        /// <param name="computeNodeEnableSchedulingOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<EnableSchedulingHeaders>> EnableSchedulingAsync(string poolId, string nodeId, ComputeNodeEnableSchedulingOptions computeNodeEnableSchedulingOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.EnableScheduling");
            scope.Start();
            try
            {
                using var message = CreateEnableSchedulingRequest(poolId, nodeId, computeNodeEnableSchedulingOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new EnableSchedulingHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can enable Task scheduling on a Compute Node only if its current scheduling state is disabled. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node on which you want to enable Task scheduling. </param>
        /// <param name="computeNodeEnableSchedulingOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<EnableSchedulingHeaders> EnableScheduling(string poolId, string nodeId, ComputeNodeEnableSchedulingOptions computeNodeEnableSchedulingOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.EnableScheduling");
            scope.Start();
            try
            {
                using var message = CreateEnableSchedulingRequest(poolId, nodeId, computeNodeEnableSchedulingOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new EnableSchedulingHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetRemoteLoginSettingsRequest(string poolId, string nodeId, ComputeNodeGetRemoteLoginSettingsOptions computeNodeGetRemoteLoginSettingsOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/remoteloginsettings", false);
            if (computeNodeGetRemoteLoginSettingsOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeGetRemoteLoginSettingsOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (computeNodeGetRemoteLoginSettingsOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeGetRemoteLoginSettingsOptions.ClientRequestId.Value);
            }
            if (computeNodeGetRemoteLoginSettingsOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeGetRemoteLoginSettingsOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeGetRemoteLoginSettingsOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeGetRemoteLoginSettingsOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Before you can remotely login to a Compute Node using the remote login settings, you must create a user Account on the Compute Node. This API can be invoked only on Pools created with the virtual machine configuration property. For Pools created with a cloud service configuration, see the GetRemoteDesktop API. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node for which to obtain the remote login settings. </param>
        /// <param name="computeNodeGetRemoteLoginSettingsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<ComputeNodeGetRemoteLoginSettingsResult, GetRemoteLoginSettingsHeaders>> GetRemoteLoginSettingsAsync(string poolId, string nodeId, ComputeNodeGetRemoteLoginSettingsOptions computeNodeGetRemoteLoginSettingsOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.GetRemoteLoginSettings");
            scope.Start();
            try
            {
                using var message = CreateGetRemoteLoginSettingsRequest(poolId, nodeId, computeNodeGetRemoteLoginSettingsOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new GetRemoteLoginSettingsHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            ComputeNodeGetRemoteLoginSettingsResult value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = ComputeNodeGetRemoteLoginSettingsResult.DeserializeComputeNodeGetRemoteLoginSettingsResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Before you can remotely login to a Compute Node using the remote login settings, you must create a user Account on the Compute Node. This API can be invoked only on Pools created with the virtual machine configuration property. For Pools created with a cloud service configuration, see the GetRemoteDesktop API. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node for which to obtain the remote login settings. </param>
        /// <param name="computeNodeGetRemoteLoginSettingsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<ComputeNodeGetRemoteLoginSettingsResult, GetRemoteLoginSettingsHeaders> GetRemoteLoginSettings(string poolId, string nodeId, ComputeNodeGetRemoteLoginSettingsOptions computeNodeGetRemoteLoginSettingsOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.GetRemoteLoginSettings");
            scope.Start();
            try
            {
                using var message = CreateGetRemoteLoginSettingsRequest(poolId, nodeId, computeNodeGetRemoteLoginSettingsOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new GetRemoteLoginSettingsHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            ComputeNodeGetRemoteLoginSettingsResult value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = ComputeNodeGetRemoteLoginSettingsResult.DeserializeComputeNodeGetRemoteLoginSettingsResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetRemoteDesktopRequest(string poolId, string nodeId, ComputeNodeGetRemoteDesktopOptions computeNodeGetRemoteDesktopOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/rdp", false);
            if (computeNodeGetRemoteDesktopOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeGetRemoteDesktopOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (computeNodeGetRemoteDesktopOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeGetRemoteDesktopOptions.ClientRequestId.Value);
            }
            if (computeNodeGetRemoteDesktopOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeGetRemoteDesktopOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeGetRemoteDesktopOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeGetRemoteDesktopOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Before you can access a Compute Node by using the RDP file, you must create a user Account on the Compute Node. This API can only be invoked on Pools created with a cloud service configuration. For Pools created with a virtual machine configuration, see the GetRemoteLoginSettings API. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node for which you want to get the Remote Desktop Protocol file. </param>
        /// <param name="computeNodeGetRemoteDesktopOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<Stream, GetRemoteDesktopHeaders>> GetRemoteDesktopAsync(string poolId, string nodeId, ComputeNodeGetRemoteDesktopOptions computeNodeGetRemoteDesktopOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.GetRemoteDesktop");
            scope.Start();
            try
            {
                using var message = CreateGetRemoteDesktopRequest(poolId, nodeId, computeNodeGetRemoteDesktopOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new GetRemoteDesktopHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            var value = message.ExtractResponseContent();
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Before you can access a Compute Node by using the RDP file, you must create a user Account on the Compute Node. This API can only be invoked on Pools created with a cloud service configuration. For Pools created with a virtual machine configuration, see the GetRemoteLoginSettings API. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node for which you want to get the Remote Desktop Protocol file. </param>
        /// <param name="computeNodeGetRemoteDesktopOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<Stream, GetRemoteDesktopHeaders> GetRemoteDesktop(string poolId, string nodeId, ComputeNodeGetRemoteDesktopOptions computeNodeGetRemoteDesktopOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.GetRemoteDesktop");
            scope.Start();
            try
            {
                using var message = CreateGetRemoteDesktopRequest(poolId, nodeId, computeNodeGetRemoteDesktopOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new GetRemoteDesktopHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            var value = message.ExtractResponseContent();
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateUploadBatchServiceLogsRequest(string poolId, string nodeId, UploadBatchServiceLogsConfiguration uploadBatchServiceLogsConfiguration, ComputeNodeUploadBatchServiceLogsOptions computeNodeUploadBatchServiceLogsOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/uploadbatchservicelogs", false);
            if (computeNodeUploadBatchServiceLogsOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeUploadBatchServiceLogsOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (computeNodeUploadBatchServiceLogsOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeUploadBatchServiceLogsOptions.ClientRequestId.Value);
            }
            if (computeNodeUploadBatchServiceLogsOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeUploadBatchServiceLogsOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeUploadBatchServiceLogsOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeUploadBatchServiceLogsOptions.OcpDate.Value, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            using var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(uploadBatchServiceLogsConfiguration);
            request.Content = content;
            return message;
        }

        /// <summary> This is for gathering Azure Batch service log files in an automated fashion from Compute Nodes if you are experiencing an error and wish to escalate to Azure support. The Azure Batch service log files should be shared with Azure support to aid in debugging issues with the Batch service. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node from which you want to upload the Azure Batch service log files. </param>
        /// <param name="uploadBatchServiceLogsConfiguration"> The Azure Batch service log files upload configuration. </param>
        /// <param name="computeNodeUploadBatchServiceLogsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<UploadBatchServiceLogsResult, UploadBatchServiceLogsHeaders>> UploadBatchServiceLogsAsync(string poolId, string nodeId, UploadBatchServiceLogsConfiguration uploadBatchServiceLogsConfiguration, ComputeNodeUploadBatchServiceLogsOptions computeNodeUploadBatchServiceLogsOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (uploadBatchServiceLogsConfiguration == null)
            {
                throw new ArgumentNullException(nameof(uploadBatchServiceLogsConfiguration));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.UploadBatchServiceLogs");
            scope.Start();
            try
            {
                using var message = CreateUploadBatchServiceLogsRequest(poolId, nodeId, uploadBatchServiceLogsConfiguration, computeNodeUploadBatchServiceLogsOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new UploadBatchServiceLogsHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            UploadBatchServiceLogsResult value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = UploadBatchServiceLogsResult.DeserializeUploadBatchServiceLogsResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This is for gathering Azure Batch service log files in an automated fashion from Compute Nodes if you are experiencing an error and wish to escalate to Azure support. The Azure Batch service log files should be shared with Azure support to aid in debugging issues with the Batch service. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node from which you want to upload the Azure Batch service log files. </param>
        /// <param name="uploadBatchServiceLogsConfiguration"> The Azure Batch service log files upload configuration. </param>
        /// <param name="computeNodeUploadBatchServiceLogsOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<UploadBatchServiceLogsResult, UploadBatchServiceLogsHeaders> UploadBatchServiceLogs(string poolId, string nodeId, UploadBatchServiceLogsConfiguration uploadBatchServiceLogsConfiguration, ComputeNodeUploadBatchServiceLogsOptions computeNodeUploadBatchServiceLogsOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (uploadBatchServiceLogsConfiguration == null)
            {
                throw new ArgumentNullException(nameof(uploadBatchServiceLogsConfiguration));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.UploadBatchServiceLogs");
            scope.Start();
            try
            {
                using var message = CreateUploadBatchServiceLogsRequest(poolId, nodeId, uploadBatchServiceLogsConfiguration, computeNodeUploadBatchServiceLogsOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new UploadBatchServiceLogsHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            UploadBatchServiceLogsResult value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = UploadBatchServiceLogsResult.DeserializeUploadBatchServiceLogsResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateListRequest(string poolId, ComputeNodeListOptions computeNodeListOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes", false);
            if (computeNodeListOptions?.Filter != null)
            {
                uri.AppendQuery("$filter", computeNodeListOptions.Filter, true);
            }
            if (computeNodeListOptions?.Select != null)
            {
                uri.AppendQuery("$select", computeNodeListOptions.Select, true);
            }
            if (computeNodeListOptions?.MaxResults != null)
            {
                uri.AppendQuery("maxresults", computeNodeListOptions.MaxResults.Value, true);
            }
            if (computeNodeListOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", computeNodeListOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (computeNodeListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeListOptions.ClientRequestId.Value);
            }
            if (computeNodeListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeListOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeListOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Lists the Compute Nodes in the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool from which you want to list Compute Nodes. </param>
        /// <param name="computeNodeListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<ComputeNodeListResult, ListHeaders>> ListAsync(string poolId, ComputeNodeListOptions computeNodeListOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.List");
            scope.Start();
            try
            {
                using var message = CreateListRequest(poolId, computeNodeListOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new ListHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            ComputeNodeListResult value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = ComputeNodeListResult.DeserializeComputeNodeListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the Compute Nodes in the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool from which you want to list Compute Nodes. </param>
        /// <param name="computeNodeListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<ComputeNodeListResult, ListHeaders> List(string poolId, ComputeNodeListOptions computeNodeListOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.List");
            scope.Start();
            try
            {
                using var message = CreateListRequest(poolId, computeNodeListOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new ListHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            ComputeNodeListResult value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = ComputeNodeListResult.DeserializeComputeNodeListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateListNextPageRequest(string nextLink, string poolId, ComputeNodeListOptions computeNodeListOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(nextLink, false);
            request.Uri = uri;
            if (computeNodeListOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", computeNodeListOptions.ClientRequestId.Value);
            }
            if (computeNodeListOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", computeNodeListOptions.ReturnClientRequestId.Value);
            }
            if (computeNodeListOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", computeNodeListOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Lists the Compute Nodes in the specified Pool. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="poolId"> The ID of the Pool from which you want to list Compute Nodes. </param>
        /// <param name="computeNodeListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<ComputeNodeListResult, ListHeaders>> ListNextPageAsync(string nextLink, string poolId, ComputeNodeListOptions computeNodeListOptions, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.List");
            scope.Start();
            try
            {
                using var message = CreateListNextPageRequest(nextLink, poolId, computeNodeListOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new ListHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            ComputeNodeListResult value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = ComputeNodeListResult.DeserializeComputeNodeListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the Compute Nodes in the specified Pool. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="poolId"> The ID of the Pool from which you want to list Compute Nodes. </param>
        /// <param name="computeNodeListOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<ComputeNodeListResult, ListHeaders> ListNextPage(string nextLink, string poolId, ComputeNodeListOptions computeNodeListOptions, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }

            using var scope = clientDiagnostics.CreateScope("ComputeNodeClient.List");
            scope.Start();
            try
            {
                using var message = CreateListNextPageRequest(nextLink, poolId, computeNodeListOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new ListHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            ComputeNodeListResult value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = ComputeNodeListResult.DeserializeComputeNodeListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}
