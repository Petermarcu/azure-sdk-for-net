// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.IO;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Batch.Models;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Batch
{
    internal partial class FileRestClient
    {
        private string batchUrl;
        private string apiVersion;
        private ClientDiagnostics clientDiagnostics;
        private HttpPipeline pipeline;

        /// <summary> Initializes a new instance of FileRestClient. </summary>
        public FileRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string batchUrl, string apiVersion = "2020-03-01.11.0")
        {
            if (batchUrl == null)
            {
                throw new ArgumentNullException(nameof(batchUrl));
            }
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            this.batchUrl = batchUrl;
            this.apiVersion = apiVersion;
            this.clientDiagnostics = clientDiagnostics;
            this.pipeline = pipeline;
        }

        internal HttpMessage CreateDeleteFromTaskRequest(string jobId, string taskId, string filePath, bool? recursive, FileDeleteFromTaskOptions fileDeleteFromTaskOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(filePath, true);
            if (recursive != null)
            {
                uri.AppendQuery("recursive", recursive.Value, true);
            }
            if (fileDeleteFromTaskOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", fileDeleteFromTaskOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (fileDeleteFromTaskOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileDeleteFromTaskOptions.ClientRequestId.Value);
            }
            if (fileDeleteFromTaskOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileDeleteFromTaskOptions.ReturnClientRequestId.Value);
            }
            if (fileDeleteFromTaskOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileDeleteFromTaskOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Deletes the specified Task file from the Compute Node where the Task ran. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to delete. </param>
        /// <param name="filePath"> The path to the Task file or directory that you want to delete. </param>
        /// <param name="recursive"> Whether to delete children of a directory. If the filePath parameter represents a directory instead of a file, you can set recursive to true to delete the directory and all of the files and subdirectories in it. If recursive is false then the directory must be empty or deletion will fail. </param>
        /// <param name="fileDeleteFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<DeleteFromTaskHeaders>> DeleteFromTaskAsync(string jobId, string taskId, string filePath, bool? recursive, FileDeleteFromTaskOptions fileDeleteFromTaskOptions, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.DeleteFromTask");
            scope.Start();
            try
            {
                using var message = CreateDeleteFromTaskRequest(jobId, taskId, filePath, recursive, fileDeleteFromTaskOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new DeleteFromTaskHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes the specified Task file from the Compute Node where the Task ran. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to delete. </param>
        /// <param name="filePath"> The path to the Task file or directory that you want to delete. </param>
        /// <param name="recursive"> Whether to delete children of a directory. If the filePath parameter represents a directory instead of a file, you can set recursive to true to delete the directory and all of the files and subdirectories in it. If recursive is false then the directory must be empty or deletion will fail. </param>
        /// <param name="fileDeleteFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<DeleteFromTaskHeaders> DeleteFromTask(string jobId, string taskId, string filePath, bool? recursive, FileDeleteFromTaskOptions fileDeleteFromTaskOptions, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.DeleteFromTask");
            scope.Start();
            try
            {
                using var message = CreateDeleteFromTaskRequest(jobId, taskId, filePath, recursive, fileDeleteFromTaskOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new DeleteFromTaskHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetFromTaskRequest(string jobId, string taskId, string filePath, FileGetFromTaskOptions fileGetFromTaskOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(filePath, true);
            if (fileGetFromTaskOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", fileGetFromTaskOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (fileGetFromTaskOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileGetFromTaskOptions.ClientRequestId.Value);
            }
            if (fileGetFromTaskOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileGetFromTaskOptions.ReturnClientRequestId.Value);
            }
            if (fileGetFromTaskOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileGetFromTaskOptions.OcpDate.Value, "R");
            }
            if (fileGetFromTaskOptions?.OcpRange != null)
            {
                request.Headers.Add("ocp-range", fileGetFromTaskOptions.OcpRange);
            }
            if (fileGetFromTaskOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", fileGetFromTaskOptions.IfModifiedSince.Value, "R");
            }
            if (fileGetFromTaskOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", fileGetFromTaskOptions.IfUnmodifiedSince.Value, "R");
            }
            return message;
        }

        /// <summary> Returns the content of the specified Task file. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        /// <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        /// <param name="fileGetFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<Stream, GetFromTaskHeaders>> GetFromTaskAsync(string jobId, string taskId, string filePath, FileGetFromTaskOptions fileGetFromTaskOptions, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.GetFromTask");
            scope.Start();
            try
            {
                using var message = CreateGetFromTaskRequest(jobId, taskId, filePath, fileGetFromTaskOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new GetFromTaskHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            var value = message.ExtractResponseContent();
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the content of the specified Task file. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        /// <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        /// <param name="fileGetFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<Stream, GetFromTaskHeaders> GetFromTask(string jobId, string taskId, string filePath, FileGetFromTaskOptions fileGetFromTaskOptions, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.GetFromTask");
            scope.Start();
            try
            {
                using var message = CreateGetFromTaskRequest(jobId, taskId, filePath, fileGetFromTaskOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new GetFromTaskHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            var value = message.ExtractResponseContent();
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetPropertiesFromTaskRequest(string jobId, string taskId, string filePath, FileGetPropertiesFromTaskOptions fileGetPropertiesFromTaskOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(filePath, true);
            if (fileGetPropertiesFromTaskOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", fileGetPropertiesFromTaskOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (fileGetPropertiesFromTaskOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileGetPropertiesFromTaskOptions.ClientRequestId.Value);
            }
            if (fileGetPropertiesFromTaskOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileGetPropertiesFromTaskOptions.ReturnClientRequestId.Value);
            }
            if (fileGetPropertiesFromTaskOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileGetPropertiesFromTaskOptions.OcpDate.Value, "R");
            }
            if (fileGetPropertiesFromTaskOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", fileGetPropertiesFromTaskOptions.IfModifiedSince.Value, "R");
            }
            if (fileGetPropertiesFromTaskOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", fileGetPropertiesFromTaskOptions.IfUnmodifiedSince.Value, "R");
            }
            return message;
        }

        /// <summary> Gets the properties of the specified Task file. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to get the properties of. </param>
        /// <param name="filePath"> The path to the Task file that you want to get the properties of. </param>
        /// <param name="fileGetPropertiesFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<GetPropertiesFromTaskHeaders>> GetPropertiesFromTaskAsync(string jobId, string taskId, string filePath, FileGetPropertiesFromTaskOptions fileGetPropertiesFromTaskOptions, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.GetPropertiesFromTask");
            scope.Start();
            try
            {
                using var message = CreateGetPropertiesFromTaskRequest(jobId, taskId, filePath, fileGetPropertiesFromTaskOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new GetPropertiesFromTaskHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the properties of the specified Task file. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to get the properties of. </param>
        /// <param name="filePath"> The path to the Task file that you want to get the properties of. </param>
        /// <param name="fileGetPropertiesFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<GetPropertiesFromTaskHeaders> GetPropertiesFromTask(string jobId, string taskId, string filePath, FileGetPropertiesFromTaskOptions fileGetPropertiesFromTaskOptions, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.GetPropertiesFromTask");
            scope.Start();
            try
            {
                using var message = CreateGetPropertiesFromTaskRequest(jobId, taskId, filePath, fileGetPropertiesFromTaskOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new GetPropertiesFromTaskHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateDeleteFromComputeNodeRequest(string poolId, string nodeId, string filePath, bool? recursive, FileDeleteFromComputeNodeOptions fileDeleteFromComputeNodeOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(filePath, true);
            if (recursive != null)
            {
                uri.AppendQuery("recursive", recursive.Value, true);
            }
            if (fileDeleteFromComputeNodeOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", fileDeleteFromComputeNodeOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (fileDeleteFromComputeNodeOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileDeleteFromComputeNodeOptions.ClientRequestId.Value);
            }
            if (fileDeleteFromComputeNodeOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileDeleteFromComputeNodeOptions.ReturnClientRequestId.Value);
            }
            if (fileDeleteFromComputeNodeOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileDeleteFromComputeNodeOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Deletes the specified file from the Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node from which you want to delete the file. </param>
        /// <param name="filePath"> The path to the file or directory that you want to delete. </param>
        /// <param name="recursive"> Whether to delete children of a directory. If the filePath parameter represents a directory instead of a file, you can set recursive to true to delete the directory and all of the files and subdirectories in it. If recursive is false then the directory must be empty or deletion will fail. </param>
        /// <param name="fileDeleteFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<DeleteFromComputeNodeHeaders>> DeleteFromComputeNodeAsync(string poolId, string nodeId, string filePath, bool? recursive, FileDeleteFromComputeNodeOptions fileDeleteFromComputeNodeOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.DeleteFromComputeNode");
            scope.Start();
            try
            {
                using var message = CreateDeleteFromComputeNodeRequest(poolId, nodeId, filePath, recursive, fileDeleteFromComputeNodeOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new DeleteFromComputeNodeHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes the specified file from the Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node from which you want to delete the file. </param>
        /// <param name="filePath"> The path to the file or directory that you want to delete. </param>
        /// <param name="recursive"> Whether to delete children of a directory. If the filePath parameter represents a directory instead of a file, you can set recursive to true to delete the directory and all of the files and subdirectories in it. If recursive is false then the directory must be empty or deletion will fail. </param>
        /// <param name="fileDeleteFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<DeleteFromComputeNodeHeaders> DeleteFromComputeNode(string poolId, string nodeId, string filePath, bool? recursive, FileDeleteFromComputeNodeOptions fileDeleteFromComputeNodeOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.DeleteFromComputeNode");
            scope.Start();
            try
            {
                using var message = CreateDeleteFromComputeNodeRequest(poolId, nodeId, filePath, recursive, fileDeleteFromComputeNodeOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new DeleteFromComputeNodeHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetFromComputeNodeRequest(string poolId, string nodeId, string filePath, FileGetFromComputeNodeOptions fileGetFromComputeNodeOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(filePath, true);
            if (fileGetFromComputeNodeOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", fileGetFromComputeNodeOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (fileGetFromComputeNodeOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileGetFromComputeNodeOptions.ClientRequestId.Value);
            }
            if (fileGetFromComputeNodeOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileGetFromComputeNodeOptions.ReturnClientRequestId.Value);
            }
            if (fileGetFromComputeNodeOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileGetFromComputeNodeOptions.OcpDate.Value, "R");
            }
            if (fileGetFromComputeNodeOptions?.OcpRange != null)
            {
                request.Headers.Add("ocp-range", fileGetFromComputeNodeOptions.OcpRange);
            }
            if (fileGetFromComputeNodeOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", fileGetFromComputeNodeOptions.IfModifiedSince.Value, "R");
            }
            if (fileGetFromComputeNodeOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", fileGetFromComputeNodeOptions.IfUnmodifiedSince.Value, "R");
            }
            return message;
        }

        /// <summary> Returns the content of the specified Compute Node file. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that contains the file. </param>
        /// <param name="filePath"> The path to the Compute Node file that you want to get the content of. </param>
        /// <param name="fileGetFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<Stream, GetFromComputeNodeHeaders>> GetFromComputeNodeAsync(string poolId, string nodeId, string filePath, FileGetFromComputeNodeOptions fileGetFromComputeNodeOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.GetFromComputeNode");
            scope.Start();
            try
            {
                using var message = CreateGetFromComputeNodeRequest(poolId, nodeId, filePath, fileGetFromComputeNodeOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new GetFromComputeNodeHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            var value = message.ExtractResponseContent();
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the content of the specified Compute Node file. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that contains the file. </param>
        /// <param name="filePath"> The path to the Compute Node file that you want to get the content of. </param>
        /// <param name="fileGetFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<Stream, GetFromComputeNodeHeaders> GetFromComputeNode(string poolId, string nodeId, string filePath, FileGetFromComputeNodeOptions fileGetFromComputeNodeOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.GetFromComputeNode");
            scope.Start();
            try
            {
                using var message = CreateGetFromComputeNodeRequest(poolId, nodeId, filePath, fileGetFromComputeNodeOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new GetFromComputeNodeHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            var value = message.ExtractResponseContent();
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetPropertiesFromComputeNodeRequest(string poolId, string nodeId, string filePath, FileGetPropertiesFromComputeNodeOptions fileGetPropertiesFromComputeNodeOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(filePath, true);
            if (fileGetPropertiesFromComputeNodeOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", fileGetPropertiesFromComputeNodeOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (fileGetPropertiesFromComputeNodeOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileGetPropertiesFromComputeNodeOptions.ClientRequestId.Value);
            }
            if (fileGetPropertiesFromComputeNodeOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileGetPropertiesFromComputeNodeOptions.ReturnClientRequestId.Value);
            }
            if (fileGetPropertiesFromComputeNodeOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileGetPropertiesFromComputeNodeOptions.OcpDate.Value, "R");
            }
            if (fileGetPropertiesFromComputeNodeOptions?.IfModifiedSince != null)
            {
                request.Headers.Add("If-Modified-Since", fileGetPropertiesFromComputeNodeOptions.IfModifiedSince.Value, "R");
            }
            if (fileGetPropertiesFromComputeNodeOptions?.IfUnmodifiedSince != null)
            {
                request.Headers.Add("If-Unmodified-Since", fileGetPropertiesFromComputeNodeOptions.IfUnmodifiedSince.Value, "R");
            }
            return message;
        }

        /// <summary> Gets the properties of the specified Compute Node file. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that contains the file. </param>
        /// <param name="filePath"> The path to the Compute Node file that you want to get the properties of. </param>
        /// <param name="fileGetPropertiesFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<GetPropertiesFromComputeNodeHeaders>> GetPropertiesFromComputeNodeAsync(string poolId, string nodeId, string filePath, FileGetPropertiesFromComputeNodeOptions fileGetPropertiesFromComputeNodeOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.GetPropertiesFromComputeNode");
            scope.Start();
            try
            {
                using var message = CreateGetPropertiesFromComputeNodeRequest(poolId, nodeId, filePath, fileGetPropertiesFromComputeNodeOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new GetPropertiesFromComputeNodeHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the properties of the specified Compute Node file. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that contains the file. </param>
        /// <param name="filePath"> The path to the Compute Node file that you want to get the properties of. </param>
        /// <param name="fileGetPropertiesFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<GetPropertiesFromComputeNodeHeaders> GetPropertiesFromComputeNode(string poolId, string nodeId, string filePath, FileGetPropertiesFromComputeNodeOptions fileGetPropertiesFromComputeNodeOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }
            if (filePath == null)
            {
                throw new ArgumentNullException(nameof(filePath));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.GetPropertiesFromComputeNode");
            scope.Start();
            try
            {
                using var message = CreateGetPropertiesFromComputeNodeRequest(poolId, nodeId, filePath, fileGetPropertiesFromComputeNodeOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new GetPropertiesFromComputeNodeHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        return ResponseWithHeaders.FromValue(headers, message.Response);
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateListFromTaskRequest(string jobId, string taskId, bool? recursive, FileListFromTaskOptions fileListFromTaskOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/files", false);
            if (fileListFromTaskOptions?.Filter != null)
            {
                uri.AppendQuery("$filter", fileListFromTaskOptions.Filter, true);
            }
            if (recursive != null)
            {
                uri.AppendQuery("recursive", recursive.Value, true);
            }
            if (fileListFromTaskOptions?.MaxResults != null)
            {
                uri.AppendQuery("maxresults", fileListFromTaskOptions.MaxResults.Value, true);
            }
            if (fileListFromTaskOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", fileListFromTaskOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (fileListFromTaskOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileListFromTaskOptions.ClientRequestId.Value);
            }
            if (fileListFromTaskOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileListFromTaskOptions.ReturnClientRequestId.Value);
            }
            if (fileListFromTaskOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileListFromTaskOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Lists the files in a Task&apos;s directory on its Compute Node. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose files you want to list. </param>
        /// <param name="recursive"> Whether to list children of the Task directory. This parameter can be used in combination with the filter parameter to list specific type of files. </param>
        /// <param name="fileListFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<NodeFileListResult, ListFromTaskHeaders>> ListFromTaskAsync(string jobId, string taskId, bool? recursive, FileListFromTaskOptions fileListFromTaskOptions, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.ListFromTask");
            scope.Start();
            try
            {
                using var message = CreateListFromTaskRequest(jobId, taskId, recursive, fileListFromTaskOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new ListFromTaskHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            NodeFileListResult value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = NodeFileListResult.DeserializeNodeFileListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the files in a Task&apos;s directory on its Compute Node. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose files you want to list. </param>
        /// <param name="recursive"> Whether to list children of the Task directory. This parameter can be used in combination with the filter parameter to list specific type of files. </param>
        /// <param name="fileListFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<NodeFileListResult, ListFromTaskHeaders> ListFromTask(string jobId, string taskId, bool? recursive, FileListFromTaskOptions fileListFromTaskOptions, CancellationToken cancellationToken = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.ListFromTask");
            scope.Start();
            try
            {
                using var message = CreateListFromTaskRequest(jobId, taskId, recursive, fileListFromTaskOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new ListFromTaskHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            NodeFileListResult value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = NodeFileListResult.DeserializeNodeFileListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateListFromComputeNodeRequest(string poolId, string nodeId, bool? recursive, FileListFromComputeNodeOptions fileListFromComputeNodeOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/files", false);
            if (fileListFromComputeNodeOptions?.Filter != null)
            {
                uri.AppendQuery("$filter", fileListFromComputeNodeOptions.Filter, true);
            }
            if (recursive != null)
            {
                uri.AppendQuery("recursive", recursive.Value, true);
            }
            if (fileListFromComputeNodeOptions?.MaxResults != null)
            {
                uri.AppendQuery("maxresults", fileListFromComputeNodeOptions.MaxResults.Value, true);
            }
            if (fileListFromComputeNodeOptions?.Timeout != null)
            {
                uri.AppendQuery("timeout", fileListFromComputeNodeOptions.Timeout.Value, true);
            }
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (fileListFromComputeNodeOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileListFromComputeNodeOptions.ClientRequestId.Value);
            }
            if (fileListFromComputeNodeOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileListFromComputeNodeOptions.ReturnClientRequestId.Value);
            }
            if (fileListFromComputeNodeOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileListFromComputeNodeOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Lists all of the files in Task directories on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node whose files you want to list. </param>
        /// <param name="recursive"> Whether to list children of a directory. </param>
        /// <param name="fileListFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<NodeFileListResult, ListFromComputeNodeHeaders>> ListFromComputeNodeAsync(string poolId, string nodeId, bool? recursive, FileListFromComputeNodeOptions fileListFromComputeNodeOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.ListFromComputeNode");
            scope.Start();
            try
            {
                using var message = CreateListFromComputeNodeRequest(poolId, nodeId, recursive, fileListFromComputeNodeOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new ListFromComputeNodeHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            NodeFileListResult value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = NodeFileListResult.DeserializeNodeFileListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all of the files in Task directories on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node whose files you want to list. </param>
        /// <param name="recursive"> Whether to list children of a directory. </param>
        /// <param name="fileListFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<NodeFileListResult, ListFromComputeNodeHeaders> ListFromComputeNode(string poolId, string nodeId, bool? recursive, FileListFromComputeNodeOptions fileListFromComputeNodeOptions, CancellationToken cancellationToken = default)
        {
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.ListFromComputeNode");
            scope.Start();
            try
            {
                using var message = CreateListFromComputeNodeRequest(poolId, nodeId, recursive, fileListFromComputeNodeOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new ListFromComputeNodeHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            NodeFileListResult value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = NodeFileListResult.DeserializeNodeFileListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateListFromTaskNextPageRequest(string nextLink, string jobId, string taskId, bool? recursive, FileListFromTaskOptions fileListFromTaskOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(nextLink, false);
            request.Uri = uri;
            if (fileListFromTaskOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileListFromTaskOptions.ClientRequestId.Value);
            }
            if (fileListFromTaskOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileListFromTaskOptions.ReturnClientRequestId.Value);
            }
            if (fileListFromTaskOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileListFromTaskOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Lists the files in a Task&apos;s directory on its Compute Node. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose files you want to list. </param>
        /// <param name="recursive"> Whether to list children of the Task directory. This parameter can be used in combination with the filter parameter to list specific type of files. </param>
        /// <param name="fileListFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<NodeFileListResult, ListFromTaskHeaders>> ListFromTaskNextPageAsync(string nextLink, string jobId, string taskId, bool? recursive, FileListFromTaskOptions fileListFromTaskOptions, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.ListFromTask");
            scope.Start();
            try
            {
                using var message = CreateListFromTaskNextPageRequest(nextLink, jobId, taskId, recursive, fileListFromTaskOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new ListFromTaskHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            NodeFileListResult value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = NodeFileListResult.DeserializeNodeFileListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the files in a Task&apos;s directory on its Compute Node. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose files you want to list. </param>
        /// <param name="recursive"> Whether to list children of the Task directory. This parameter can be used in combination with the filter parameter to list specific type of files. </param>
        /// <param name="fileListFromTaskOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<NodeFileListResult, ListFromTaskHeaders> ListFromTaskNextPage(string nextLink, string jobId, string taskId, bool? recursive, FileListFromTaskOptions fileListFromTaskOptions, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (taskId == null)
            {
                throw new ArgumentNullException(nameof(taskId));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.ListFromTask");
            scope.Start();
            try
            {
                using var message = CreateListFromTaskNextPageRequest(nextLink, jobId, taskId, recursive, fileListFromTaskOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new ListFromTaskHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            NodeFileListResult value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = NodeFileListResult.DeserializeNodeFileListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateListFromComputeNodeNextPageRequest(string nextLink, string poolId, string nodeId, bool? recursive, FileListFromComputeNodeOptions fileListFromComputeNodeOptions)
        {
            var message = pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(nextLink, false);
            request.Uri = uri;
            if (fileListFromComputeNodeOptions?.ClientRequestId != null)
            {
                request.Headers.Add("client-request-id", fileListFromComputeNodeOptions.ClientRequestId.Value);
            }
            if (fileListFromComputeNodeOptions?.ReturnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", fileListFromComputeNodeOptions.ReturnClientRequestId.Value);
            }
            if (fileListFromComputeNodeOptions?.OcpDate != null)
            {
                request.Headers.Add("ocp-date", fileListFromComputeNodeOptions.OcpDate.Value, "R");
            }
            return message;
        }

        /// <summary> Lists all of the files in Task directories on the specified Compute Node. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node whose files you want to list. </param>
        /// <param name="recursive"> Whether to list children of a directory. </param>
        /// <param name="fileListFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async ValueTask<ResponseWithHeaders<NodeFileListResult, ListFromComputeNodeHeaders>> ListFromComputeNodeNextPageAsync(string nextLink, string poolId, string nodeId, bool? recursive, FileListFromComputeNodeOptions fileListFromComputeNodeOptions, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.ListFromComputeNode");
            scope.Start();
            try
            {
                using var message = CreateListFromComputeNodeNextPageRequest(nextLink, poolId, nodeId, recursive, fileListFromComputeNodeOptions);
                await pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
                var headers = new ListFromComputeNodeHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            NodeFileListResult value = default;
                            using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                            value = NodeFileListResult.DeserializeNodeFileListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw await clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all of the files in Task directories on the specified Compute Node. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node whose files you want to list. </param>
        /// <param name="recursive"> Whether to list children of a directory. </param>
        /// <param name="fileListFromComputeNodeOptions"> Parameter group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<NodeFileListResult, ListFromComputeNodeHeaders> ListFromComputeNodeNextPage(string nextLink, string poolId, string nodeId, bool? recursive, FileListFromComputeNodeOptions fileListFromComputeNodeOptions, CancellationToken cancellationToken = default)
        {
            if (nextLink == null)
            {
                throw new ArgumentNullException(nameof(nextLink));
            }
            if (poolId == null)
            {
                throw new ArgumentNullException(nameof(poolId));
            }
            if (nodeId == null)
            {
                throw new ArgumentNullException(nameof(nodeId));
            }

            using var scope = clientDiagnostics.CreateScope("FileClient.ListFromComputeNode");
            scope.Start();
            try
            {
                using var message = CreateListFromComputeNodeNextPageRequest(nextLink, poolId, nodeId, recursive, fileListFromComputeNodeOptions);
                pipeline.Send(message, cancellationToken);
                var headers = new ListFromComputeNodeHeaders(message.Response);
                switch (message.Response.Status)
                {
                    case 200:
                        {
                            NodeFileListResult value = default;
                            using var document = JsonDocument.Parse(message.Response.ContentStream);
                            value = NodeFileListResult.DeserializeNodeFileListResult(document.RootElement);
                            return ResponseWithHeaders.FromValue(value, headers, message.Response);
                        }
                    default:
                        throw clientDiagnostics.CreateRequestFailedException(message.Response);
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}
